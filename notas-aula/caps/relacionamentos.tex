\chapter{Relacionamentos entre classes }

\section{Visão geral}

As classes podem se conter relacionamentos entre si, definindo um vínculo entre seus objetos. Considerando as entidades em negrito, alguns exemplos de relacionamentos entre classes incluem:

\begin{itemize}
	\item Um \textbf{cliente} possui um \textbf{endereço}.
	\item Uma \textbf{empresa} é composta por \textbf{funcionários}.
	\item Uma \textbf{moto} é um tipo de \textbf{veículo}.
	\item Um \textbf{restaurante} possui \textbf{pratos}.
	\item Uma \textbf{correspondência} possui um \textbf{remetente} e um \textbf{destinatário}.
\end{itemize}

Existem diferentes tipos de relacionamentos. A lista abaixo resume os principais tipos de relacionamentos, os quais serão detalhados neste capítulo.

\begin{itemize}
	\item \textbf{Associação:} conexão entre classes.
	\item \textbf{Agregação e composição:} especialização de uma associação onde um todo é relacionado com suas partes (relacionamento ``todo-parte'').
	\item \textbf{Dependência:} um objeto depende de alguma forma de outro (relacionamento de utilização).
	\item \textbf{Herança (generalização):} um dos princípios da orientação a objetos, onde uma nova classe pode ser definida a partir de outra já existente (reutilização).
	\item \textbf{Realização:} um contrato que classe segue (obrigação).
\end{itemize}

A Figura~\ref{fig:relacionamentos-uml} mostra a representação UML dos relacionamentos supracitados. Uma associação é representada por um segmento de reta que une as duas classes. Os relacionamentos de agregação e composição são representados por uma reta com um losango no lado da entidade que representa o todo. A composição se difere da primeira por apresentar o losango preenchido. A dependência é representada por uma linha tracejada com uma ponta de seta aberta no lado da classe independente. A herança é representada por uma linha com uma ponta de seta fechada no lado da superclasse. Finalmente, a realização é representada da mesma forma que uma herança, com a diferença da reta ser tracejada. O restante deste capítulo discute cada relacionamento entre classes e apresenta sua implementação utilizando a linguagem Java.

\begin{figure}[h]
	\centering
	\begin{tikzpicture}
	\umlemptyclass{A}
	\umlemptyclass[x=6]{B}
	\umlassoc[name=associacao] {A}{B}
	
	\umlemptyclass[y=-2]{A}
	\umlemptyclass[x=6,y=-2]{B}
	\umlaggreg[name=agregacao] {A}{B}
	
	\umlemptyclass[y=-4]{A}
	\umlemptyclass[x=6,y=-4]{B}
	\umlcompo[name=composicao] {A}{B}
	
	\umlemptyclass[y=-6]{A}
	\umlemptyclass[x=6,y=-6]{B}
	\umlimport[name=dependencia] {A}{B}
	
	\umlemptyclass[y=-8]{A}
	\umlemptyclass[x=6,y=-8]{B}
	\umlinherit[name=heranca] {B}{A}
	
	\umlemptyclass[y=-10]{A}
	\umlemptyclass[x=6,y=-10]{B}
	\umlreal[name=realizacao] {A}{B}
	
	\node[above] at (associacao-1) {associação};
	\node[above] at (agregacao-1) {agregação};
	\node[above] at (composicao-1) {composição};
	\node[above] at (dependencia-1) {dependência};
	\node[above] at (heranca-1) {herança};
	\node[above] at (realizacao-1) {realização};
	
	\end{tikzpicture}
	\caption{Representação UML dos relacionamentos entre classes}
	\label{fig:relacionamentos-uml}
\end{figure}


\section{Associações simples}

Uma associação é uma conexão entre classes e representa uma relação entre os objetos envolvidos. Elas são representadas em um diagrama de classes através de uma linha, que conecta as classes associadas. Os dados podem fluir em uma ou em ambas as direções através do link. Existe dois duas formas principais de associação: com multiplicidade um (1) e com multiplicidade muitos (*). Cada uma das formas de associação pode ser implementada de forma unidirecional ou bidirecional.


\subsection{Associação com multiplicidade um (1)}

Uma associação de multiplicidade 1 ocorre quanto um objeto está vinculado a apenas um objeto da outra classe. Um exemplo deste tipo de associação é o vínculo existente entre um veículo (primeira entidade -- classe) e sua documentação (segunda entidade -- classe). Um veículo possui exatamente uma documentação, enquanto uma documentação pertence a exatamente um veículo. Logo, dizemos que este relacionamento é uma \textbf{associação de um para um}.

Na associação com multiplicidade 1, ao menos um dos atributos de uma das classes é do tipo da outra classe. No exemplo envolvendo as classes \code{Veiculo} e \code{Documentacao}, o \code{Veiculo} possui um atributo do tipo \code{Documentacao} (\textbf{associação unidirecional de Veiculo para Documentacao}), ou a \code{Documentacao} possui um atributo do tipo \code{Veiculo} (\textbf{associação unidirecional de Documentacao para Veiculo}), ou ambos os casos (\textbf{associação bidirecional}).

\subsubsection{Caso unidirecional}

Consideremos o caso unidirecional. Se queremos que o atributo que implementa a associação fique na classe \code{Veiculo}, então temos uma associação unidirecional de \code{Veiculo} para \code{Documentacao}. Sua representação UML é apresentada na Figura~\ref{fig:associacao-uni-veiculo}. A direção da associação (chamada de navegabilidade) é informada através de uma ponta de seta. A navegabilidade representada na Figura~\ref{fig:associacao-uni-veiculo} mostra que a partir da classe \code{Veiculo} podemos chegar na classe \code{Documentacao}, pois existe um atributo na classe \code{Veiculo} do tipo \code{Documentacao}. Percebam que o atributo que implementa a associação não é representado no diagrama de classes, pois é implícito na representação da associação.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Veiculo}{
		-- modelo: String \\
		-- marca: String \\
		-- ano: int
		}{
		+ métodos set() e get()
		}
		
	\umlclass[x=8]{Documentacao}{
		-- renavam: int \\
		-- validade: int \\
		-- placa: String
		}{
		+ métodos set() e get()
		}
	
	\umluniassoc[geometry=-|-, mult1=1, mult2=1, pos2=2.8, align2=top]{Veiculo}{Documentacao}	
	\end{tikzpicture}
	
	\caption{Associação unidirecional de \texttt{Veiculo} para \texttt{Documentacao}}
	\label{fig:associacao-uni-veiculo}
\end{figure}

Os trechos de código abaixo mostram a implementação das classes apresentadas no diagrama da Figura~\ref{fig:associacao-uni-veiculo} (os métodos construtores e demais métodos acessores foram omitidos). Reparem o atributo \code{doc} na classe \code{Veiculo}. Assim como os demais atributos, métodos acessores são definidos para acesso à documentação do veículo (ao atributo \code{doc}).
 
\begin{minted}{java}
public class Veiculo { 
	private String modelo; 
	private String marca; 
	private int ano; 
	private Documentacao doc; 

	public Documentacao getDoc() {
		return doc;
	}
	 
	public void setDoc(Documentacao doc) {
		this.doc = doc;
	}
	
	//demais métodos
}
\end{minted}

\begin{minted}{java}
public class Documentacao { 
	private int renavam; 
	private int validade;
	private String placa; 
	
	public int getRenavam() {
		return renavam;
	}
	 
	public void setRenavam(int renavam) {
		this.renavam = renavam;
	}
	
	//demais métodos
}
\end{minted}

O trecho de código a seguir mostra o uso da associação. Uma vez que as classes estejam associadas, devemos vincular os objetos no momento da sua criação (linha 4). Além disso, podemos acessar o vínculo para recuperar valores da documentação, a partir de um objeto da classe \code{Veiculo} (linha 5). Repare que não é possível acessar os dados do veículo a partir de um objeto da classe \code{Documentacao}, uma vez que o atributo que realiza a associação encontra-se na classe \code{Veiculo}.

\begin{minted}{java}
public static void main(String[] args) { 
	Veiculo carro = new Veiculo("Focus", "Ford", 2017); 
	Documentacao doc = new Documentacao(512647522, 2018, "QWD-2573"); 
	carro.setDoc(doc);
	System.out.println("O veículo " + carro.getModelo() + " possui placa " + carro.getDoc().getPlaca()); 
}
\end{minted}

Ainda no caso unidirecional, se quisermos que o atributo que implementa a associação fique na classe \code{Documentacao}, então temos uma associação unidirecional de \code{Documentacao} para \code{Veiculo}. Sua representação UML é apresentada na Figura~\ref{fig:associacao-uni-documentacao}. A direção da associação (navegabilidade) é apresentada pela ponta de seta, que aponta para a classe \code{Veiculo}. Neste caso, a partir da classe \code{Documentacao} podemos chegar na classe \code{Veiculo}, pois existe um atributo na classe \code{Documentacao} do tipo \code{Veiculo}.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Veiculo}{
		-- modelo: String \\
		-- marca: String \\
		-- ano: int
	}{
		+ métodos set() e get()
	}
	
	\umlclass[x=8]{Documentacao}{
		-- renavam: int \\
		-- validade: int \\
		-- placa: String
	}{
		+ métodos set() e get()
	}
	
	\umluniassoc[geometry=-|-, mult1=1, mult2=1, pos2=2.8, align2=top]{Documentacao}{Veiculo}	
	\end{tikzpicture}
	
	\caption{Associação unidirecional de \texttt{Documentacao} para \texttt{Veiculo}}
	\label{fig:associacao-uni-documentacao}
\end{figure}

Os trechos de código abaixo mostram a implementação das classes apresentadas no diagrama da Figura~\ref{fig:associacao-uni-documentacao} (os métodos construtores e demais métodos acessores foram omitidos). Reparem o atributo \code{veiculo} na classe \code{Documentacao}. Assim como os demais atributos, métodos acessores são definidos para acesso ao veículo da documentação (ao atributo \code{veiculo}).

\begin{minted}{java}
public class Veiculo {
	private String modelo;
	private String marca;
	private int ano;
	
	public String getModelo() {
		return modelo;
	}
	
	public void setModelo(String modelo) {
		this.modelo = modelo;
	}
	
	//demais métodos
}
\end{minted}

\begin{minted}{java}
public class Documentacao {
	private int renavam;
	private int validade;
	private String placa;
	private Veiculo veiculo;
	
	public Veiculo getVeiculo() {
		return veiculo;
	}
	
	public void setVeiculo(Veiculo veiculo){
		this.veiculo = veiculo;
	}
	
	//demais métodos
}
\end{minted}

O trecho de código a seguir mostra o uso da associação. Analogamente ao exemplo anterior, podemos acessar o vínculo para recuperar valores do veículo a partir de um objeto da classe \code{Documentacao} (linha 5). Repare que não é possível acessar os dados da documentação a partir de um objeto da classe \code{Veiculo}, uma vez que o atributo que realiza a associação encontra-se na classe \code{Documentacao}.

\begin{minted}{java}
public static void main(String[] args) {
	Veiculo carro = new Veiculo("Focus", "Ford", 2017);
	Documentacao doc = new Documentacao(512647522, 2018, "QWD-2573");
	doc.setVeiculo(carro);
	System.out.println("O documento " + doc.getRenavam() + " pertence ao veículo " + doc.getVeiculo().getModelo());
}
\end{minted}

\subsubsection{Caso bidirecional}

Se quisermos que ambas as classes possuam atributos que implementem o vínculo, podemos adotar uma associação bidirecional. Neste caso, existe um atributo da classe \code{Veiculo} na classe \code{Documentacao}, bem como um atributo da classe \code{Documentacao} na classe \code{Veiculo}. Com isso, é possível acessar a documentação a partir da classe \code{Veiculo}, bem como acessar o veículo a partir da classe \code{Documentacao}. Na UML, representamos uma associação bidirecional aplicando a ponta de seta nos dois lados da linha, ou omitindo a ponta de seta e mantendo uma linha simples (neste caso, entende-se que a associação é bidirecional). A Figura~\ref{fig:associacao-bidirecional} mostra as duas opções de representação UML de um relacionamento de associação bidirecional.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Veiculo}{
		-- modelo: String \\
		-- marca: String \\
		-- ano: int
	}{
		+ métodos set() e get()
	}
	
	\umlclass[x=8]{Documentacao}{
		-- renavam: int \\
		-- validade: int \\
		-- placa: String
	}{
		+ métodos set() e get()
	}
	
	\umlassoc[geometry=-|-, mult1=1, mult2=1, pos2=2.8, align2=top]{Documentacao}{Veiculo}	
	
	\umlclass[y=-4]{Veiculo}{
		-- modelo: String \\
		-- marca: String \\
		-- ano: int
	}{
		+ métodos set() e get()
	}
	
	\umlclass[x=8,y=-4]{Documentacao}{
		-- renavam: int \\
		-- validade: int \\
		-- placa: String
	}{
		+ métodos set() e get()
	}
	
	\umluniassoc[geometry=-|-, mult1=1, mult2=1, pos2=2.8, align2=top]{Documentacao}{Veiculo}	
	\umluniassoc[geometry=-|-]{Veiculo}{Documentacao}	
	\end{tikzpicture}
	
	\caption{Associação unidirecional de \texttt{Documentacao} para \texttt{Veiculo}}
	\label{fig:associacao-bidirecional}
\end{figure}

Os trechos de código abaixo mostram a implementação da associação bidirecional entre \code{Veiculo} e \code{Documentacao}. Repare nos atributos \code{doc} (classe \code{Veiculo}) e \code{veiculo} (classe \code{Documentacao}), os quais implementam o vínculo bidirecional e permite a navegação em ambos os sentidos.

 \begin{minted}{java}
public class Veiculo {
	private String modelo;
	private String marca;
	private int ano;
	private Documentacao doc;
	
	public Documentacao getDoc() {
		return doc;
	}
	
	public void setDoc(Documentacao doc) {
		this.doc = doc;
	}
	
	//demais métodos
}
\end{minted}

\begin{minted}{java}
public class Documentacao {
	private int renavam;
	private int validade;
	private String placa;
	private Veiculo veiculo;
	
	public Veiculo getVeiculo() {
		return veiculo;
	}
	
	public void setVeiculo(Veiculo veiculo){
		this.veiculo = veiculo;
	}
	
	//demais métodos
}
\end{minted}

O código a seguir mostra o uso das entidades com a associação bidirecional. Após a criação dos objetos, eles são vinculados nas linhas 4 e 5. Perceba que é preciso atribuir o veículo à sua documentação, e também a documentação ao seu veículo, uma vez que a associação é bidirecional. Após isso, é possível acessar os dados do veículo a partir da documentação (linha 6), bem como acessar os dados da documentação a partir do veículo (linha 7).

\begin{minted}{java}
public static void main(String[] args) {
	Veiculo carro = new Veiculo("Focus", "Ford", 2017);
	Documentacao doc = new Documentacao(512647522, 2018, "QWD-2573");
	doc.setVeiculo(carro);
	carro.setDoc(doc);
	System.out.println(doc.getRenavam() + " pertence ao " + doc.getVeiculo().getModelo());
	System.out.println(carro.getModelo() + " possui placa " + carro.getDoc().getPlaca());
}
\end{minted}

 
\subsection{Exemplo -- Gerente e Sala}
 
Consideremos as entidades \code{Gerente} e \code{Sala}. Cada gerente possui uma sala de trabalho. Cada sala é ocupada por, no máximo, um gerente. Logo, as entidades possuem uma associação, cuja multiplicidade máxima é 1. No entanto, neste caso um gerente pode não trabalhar em uma sala (caso seja um gerente externo, por exemplo). Além disso, uma sala pode não possuir nenhum gerente que trabalhe nela (uma sala vazia, por exemplo). Podemos informar a possibilidade de haver estes casos no próprio diagrama de classes, atribuindo multiplicidade \code{0..1}, ou seja, um gerente possui zero ou uma sala. Com isso, a chamada para vínculo dos objetos não é obrigatória e o atributo que implementa a associação pode não receber um vínculo (armazenar valor \code{null}).

Se desejarmos que a entidade \code{Gerente} tenha acesso aos dados da sua sala e, ao mesmo tempo, a entidade \code{Sala} tenha acesso aos dados do gerente que trabalha nela, podemos optar por uma associação bidirecional. O diagrama apresentado pela Figura~\ref{fig:gerente-sala} modela esta situação. As classes possuem uma associação bidirecional com multiplicidade \code{0..1} nos dois lados. Com isso, um gerente trabalha em uma sala ou em nenhuma sala, enquanto uma sala é habitada por um gerente, ou por nenhum gerente.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Gerente}{
		-- matricula: int \\
		-- nome: String \\
		-- funcao: String
	}{
		+ métodos set() e get()
	}
	
	\umlclass[x=8]{Sala}{
		-- numero: int \\
		-- predio: int \\
		-- andar: int
	}{
		+ métodos set() e get()
	}
	
	\umlassoc[geometry=-|-, mult1=0..1, mult2=0..1, pos1=0.25, pos2=2.75, align2=top]{Gerente}{Sala}
	\end{tikzpicture}
	
	\caption{Diagrama de classes para o exemplo \texttt{Sala} e \texttt{Gerente}}
	\label{fig:gerente-sala}
\end{figure}

Os techos de código abaixo mostram a implementação das classes \code{Gerente} e \code{Sala}. Os métodos \code{setSala} e \code{setGerente} foram implementados de tal forma que permita a chamada de uma única instrução, sem exigir que o programador faça o vínculo dos dois lados. Com isso, o programador se preocupa apenas em chamar o método \code{setSala} (da classe \code{Gerente}), que armazena o objeto recebido como parâmetro no atributo \code{sala} (linha 27) e, caso o parâmetro não seja \code{null}, atribui a si mesmo como gerente da sala (linhas 28 a 30), fazendo o vínculo nos dois lados. Já o método \code{setGerente} verifica se o parâmetro recebido não é \code{null}, neste caso o gerente antes vinculado a esta sala recebe \code{null} como sala, pois um novo gerente trabalhará nesta sala (linha 21). Finalmente, o novo gerente é atribuído (linha 22).
 
\begin{minted}{java}
public class Gerente {
	private int matricula;
	private String nome;
	private String funcao;
	private Sala sala;
	
	public Gerente() {}
	
	public Gerente(int matricula, String nome, String funcao) {
		this.matricula = matricula;
		this.nome = nome;
		this.funcao = funcao;
	}
	
	public Gerente(int matricula, String nome, String funcao, Sala sala) {
		this.matricula = matricula;
		this.nome = nome;
		this.funcao = funcao;
		setSala(sala);
	}
	
	public Sala getSala() {
		return sala;
	}
	
	public void setSala(Sala sala) {
		this.sala = sala;
		if(sala != null)
			sala.setGerente(this);
		}
	}
	
	//demais métodos acessores
}
\end{minted}
 
\begin{minted}{java}
public class Sala {
	private int numero;
	private String predio;
	private int andar;
	private Gerente gerente;
	
	public Sala() {}
	
	public Sala(int numero, String predio, int andar) {
		this.numero = numero;
		this.predio = predio;
		this.andar = andar;
	}
	
	public Gerente getGerente() {
		return gerente;
	}
	
	public void setGerente(Gerente gerente) {
		if(this.gerente != null)
			this.gerente.setSala(null);
			this.gerente = gerente;
		}
	}
	
	//demais métodos acessores
}
\end{minted}
 
Uma boa prática consiste em separar as funcionalidades do programa da classe que implementa o método \code{main}. Nos exemplos abaixo, o método \code{main} é implementado pela classe \code{Principal}, enquanto as funcionalidades do sistema são implementadas pela classe \code{Exemplo}. Esta classe ainda implementa um método \code{run}, que chama os métodos e as instruções desejadas (poderia apresentar um menu ao usuário, por exemplo). O método \code{main} apenas cria um objeto da classe \code{Exemplo} e chama o seu método \code{run}. Ou seja, a função do método \code{main} se limira a iniciar a aplicação.
 
\begin{minted}{java}
public class Principal {
	public static void main(String[] args) {
		Exemplo exemplo = new Exemplo();
		exemplo.run();
	}
}
\end{minted}
 
\begin{minted}{java}
public class Exemplo {
	private List<Sala> salas = new ArrayList<Sala>();
	private List<Gerente> gerentes = new ArrayList<Gerente>();

	public void run() {
		insereSalas();
		insereGerentes();
		mostraRegistros();
	}

	public void insereSalas() {
		Sala sala1 = new Sala(101, "Alpha", 1);
		Sala sala2 = new Sala(102, "Alpha", 1);
		Sala sala3 = new Sala(205, "Alpha", 2);
		Sala sala4 = new Sala(346, "Beta", 5);
		Sala sala5 = new Sala(12, "Gamma", 3);

		salas.add(sala1);
		salas.add(sala2);
		salas.add(sala3);
		salas.add(sala4);
		salas.add(sala5);
	}

	public void insereGerentes() {
		Gerente gerente1 = new Gerente(123456, "José da Silva", "Compras");
		Gerente gerente2 = new Gerente(654321, "Maria Pereira", "Vendas");
		Gerente gerente3 = new Gerente(123789, "João Assunção", "Marketing");
		Gerente gerente4 = new Gerente(987321, "Ana Maria Rodrigues", "Produção");

		gerente1.setSala(salas.get(0));
		gerente2.setSala(salas.get(1));
		gerente3.setSala(salas.get(2));
		gerente4.setSala(salas.get(0));

		gerentes.add(gerente1);
		gerentes.add(gerente2);
		gerentes.add(gerente3);
		gerentes.add(gerente4);
	}

	public void mostraRegistros() {
		for(Gerente g : gerentes) {
			if(g.getSala() != null)
				System.out.println(g.getNome() + " trabalha na sala " + g.getSala().getNumero() + " do prédio " + g.getSala().getPredio() + ".");
			else
				System.out.println(g.getNome() + " não possui uma sala de trabalho.");
		}

		System.out.println("");

		for(Sala s : salas) {
			if(s.getGerente() != null)
				System.out.println("Na sala " + s.getNumero() + " do prédio " + s.getPredio() + " trabalha " + s.getGerente().getNome() + ".");
			else
				System.out.println("Na sala " + s.getNumero() + " do prédio " + s.getPredio() + " não trabalha nenhum gerente.");
		}
	}
}
\end{minted}

O método \code{insereSalas} cria um conjunto de salas e insere na lista de salas. O método \code{insereGerentes} cria um conjunto de gerentes, vincula a algumas das salas criadas pelo método anterior e os insere na lista de gerentes. Repare que o vínculo é feito apenas pelo método \code{setSala}, dada a implementação apresentada anteriormente. O método \code{mostraRegistros} percorre a lista de gerentes e apresenta seu nome, a sala e o prédio onde trabalha. Caso ele não esteja vinculado a nenhuma sala (quando o atributo \code{sala} é \code{null}), é apresentada a mensagem de que o mesmo não possui sala de trabalho. Depois disso, a lista de salas é percorrida, apresentando o número da sala e seu prédio, juntamente com o nome do gerente que ocupa esta sala. Caso a sala esteja vazia (o atributo \code{gerente} é \code{null}), é apresentada a mensagem de que na referida sala não trabalha nenhum gerente.

\subsection{Associação com multiplicidade muitos (*)}
 
A associação com multiplicidade muitos (*) ocorre quanto um objeto está vinculado a vários objetos da outra classe. Um exemplo deste tipo de associação é o vínculo existente entre uma empresa (primeira entidade -- classe) e seus funcionários (segunda entidade -- classe). Um funcionário trabalha em uma empresa, e uma empresa possui vários (ou muitos) funcionários. Perceba que, agora, um objeto da classe \code{Empresa} está associado a vários objetos da classe \code{Funcionario}. Logo, dizemos que este relacionamento é uma \textbf{associação de um para muitos}.

Como em qualquer associação, os dados podem fluir em uma ou em ambas as direções através do link. Isto é, podemos implementar uma associação com multiplicidade muitos tanto na forma unidirecional, quanto bidirecional. Podemos utilizar um atributo da classe \code{Empresa} na classe \code{Funcionario} (\textbf{associação unidirecional de Funcionario para Empresa}), ou uma lista de objetos da classe \code{Funcionario} na classe \code{Empresa} (\textbf{associação unidirecional de Empresa para Funcionario}), ou ambos os casos (\textbf{associação bidirecional}). 

Repare que no caso de multiplicidade muitos, existem casos em que se faz necessário implementar a associação utilizando uma lista de objetos da outra classe. Este é o caso onde, a partir de uma empresa, desejamos obter os dados dos seus funcionários. Como a empresa não possui apenas um funcionário, não é possível implementar a associação com um objeto simples. Logo, uma lista de funcionários permite o armazenamento dos diversos funcionários da empresa.

\subsubsection{Caso unidirecional}

Consideremos o caso unidirecional. Se quisermos que o vínculo seja implementado pela classe \code{Empresa}, então temos uma associação unidirecional de \code{Empresa} para \code{Funcionario}. Sua representação UML é apresentada na Figura~\ref{fig:associacao-muitos-uni-empresa}.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Empresa}{
		-- razaoSocial: String \\
		-- nomeFantasia: String \\
		-- cnpj: String
	}{
		+ métodos set() e get()
	}
	
	\umlclass[x=8]{Funcionario}{
		-- nome: String \\
		-- cpf: String
	}{
		+ métodos set() e get()
	}
	
	\umluniassoc[geometry=-|-, mult1=1, mult2=*, pos1=0.2, pos2=2.75, align2=top]{Empresa}{Funcionario}
	\end{tikzpicture}
	
	\caption{Associação unidirecional de \texttt{Empresa} para \texttt{Funcionario}}
	\label{fig:associacao-muitos-uni-empresa}
\end{figure}

Neste caso, precisamos implementar uma lista de objetos de \code{Funcionario} na classe \code{Empresa}. Os trechos de código abaixo mostram a implementação de ambas as classes para este caso. Uma boa prática consiste em definir um método específico para adicionar um objeto na lista. Este método é apresentado nas linhas 7 a 9 da classe \code{Empresa}. Sempre que for necessário vincular um funcionário à empresa, este método pode (ou deve) ser utilizado.

\begin{minted}{java}
public class Empresa {
	private String razaoSocial;
	private String nomeFantasia;
	private String cnpj;
	private List<Funcionario> funcionarios;

	public Empresa() {
		funcionarios = new ArrayList<Funcionario>();
	}

	public void addFuncionario(Funcionario f) {
		this.funcionarios.add(f);
	}
	
	//demais métodos
}
\end{minted}

\begin{minted}{java}
public class Funcionario {
	private String nome;
	private String cpf;

	public String getNome() {
		return nome;
	}

	public void setNome(String nome) {
		this.nome = nome;
	}
	
	//demais métodos
}
\end{minted}

O trecho de código a seguir mostra o uso da associação implementada. São criados distintos objetos das classes \code{Funcionario} e \code{Empresa} (linhas 2 a 7). Após isso, os funcionários são atribuídos às respectivas empresas utilizando o método \code{addFuncionario} (linhas 9 a 11). Finalmente, todos os funcionários da empresa \code{e1} são apresentados (linhas 13 e 14). Perceba que a lista de funcionários da empresa \code{e1} é recuperada e, então, seus dados são apresentados em tela.

\begin{minted}{java}
public static void main(String[] args) {
	Funcionario f1 = new Funcionario("José da Silva", "012.541.379-33");
	Funcionario f2 = new Funcionario("Maria Pereira", "062.411.632-12");
	Funcionario f3 = new Funcionario("Pedro Ferreira", "178.219.475-25");
	
	Empresa e1 = new Empresa("Empresa 1 LTDA", "Empresa 1", "123.456.789/0001-01");
	Empresa e2 = new Empresa("Empresa 2 LTDA", "Empresa 2", "123.456.789/0001-02");
	
	e1.addFuncionario(f1);
	e1.addFuncionario(f2);
	e2.addFuncionario(f3);
	
	for(Funcionario f : e1.getFuncionarios())
		System.out.println(f.getNome() + " é funcionário na " + e1.getNomeFantasia());
}
\end{minted}

A mesma análise anterior pode ser feita na associação com multiplicidade muitos. Mantendo uma lista de funcionários para cada empresa, podemos acessar os dados dos funcionários a partir da classe \code{Empresa}. Porém, não é possível acessar os dados da empresa a partir da classe \code{Funcionario}. Para modificar isso, podemos inverter a navegabilidade da associação, de modo a manter o vínculo na classe \code{Funcionario}. Neste caso, o funcionário tem um atributo simples do tipo \code{Empresa}. Este caso está representado no diagrama da Figura~\ref{fig:associacao-muitos-uni-funcionario} e sua implementação segue os conceitos apresentados nas seções anteriores, podendo ser observada nos códigos abaixo.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Empresa}{
		-- razaoSocial: String \\
		-- nomeFantasia: String \\
		-- cnpj: String
	}{
		+ métodos set() e get()
	}
	
	\umlclass[x=8]{Funcionario}{
		-- nome: String \\
		-- cpf: String
	}{
		+ métodos set() e get()
	}
	
	\umluniassoc[geometry=-|-, mult1=1, mult2=*, pos1=0.2, pos2=2.75, align2=top]{Funcionario}{Empresa}
	\end{tikzpicture}
	
	\caption{Associação unidirecional de \texttt{Funcionario} para \texttt{Empresa}}
	\label{fig:associacao-muitos-uni-funcionario}
\end{figure}

\begin{minted}{java}
public class Empresa {
	private String razaoSocial;
	private String nomeFantasia;
	private String cnpj;
	
	public String getRazaoSocial() {
		return razaoSocial; 
	}
	
	public void setRazaoSocial(String r) {
		this.razaoSocial = r; 
	}
}
\end{minted}

\begin{minted}{java}
public class Funcionario {
	private String nome;
	private String cpf;
	private Empresa empresa;
	
	public Empresa getEmpresa() {
		return empresa; 
	}
	
	public void setEmpresa(Empresa empresa) {
		this.empresa = empresa;
	}
}
\end{minted}

\begin{minted}{java}
public static void main(String[] args) {
	Funcionario f1 = new Funcionario("José da Silva", "012.541.379-33");
	Funcionario f2 = new Funcionario("Maria Pereira", "062.411.632-12");
	Funcionario f3 = new Funcionario("Pedro Ferreira", "178.219.475-25");
	
	Empresa e1 = new Empresa("Empresa 1 LTDA", "Empresa 1", "123.456.789/0001-01");
	Empresa e2 = new Empresa("Empresa 2 LTDA", "Empresa 2", "123.456.789/0001-02");
	
	f1.setEmpresa(e1);
	f2.setEmpresa(e1);
	f3.setEmpresa(e2);
	
	System.out.println(f1.getNome() + " é func. na " + f1.getEmpresa().getNomeFantasia());
	System.out.println(f2.getNome() + " é func. na " + f2.getEmpresa().getNomeFantasia());
	System.out.println(f3.getNome() + " é func. na " + f3.getEmpresa().getNomeFantasia());
}
\end{minted}
 
\subsubsection{Caso bidirecional}

Se quisermos que ambas as classes possuam atributos que implementem o vínculo, podemos adotar uma associação bidirecional. Neste caso, existe uma lista de objetos de \code{Funcionario} na classe \code{Empresa}, e um objeto da classe \code{Empresa} na classe \code{Funcionario}. Com isso, é possível acessar todos os funcionários de uma empresa, bem como a empresa em que um determinado funcionário trabalha. A Figura~\ref{fig:associacao-bidirecional-empresa} apresenta a representação UML com relacionamento bidirecional entre as classes.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Empresa}{
		-- razaoSocial: String \\
		-- nomeFantasia: String \\
		-- cnpj: String
	}{
		+ métodos set() e get()
	}
	
	\umlclass[x=8]{Funcionario}{
		-- nome: String \\
		-- cpf: String
	}{
	+ métodos set() e get()
	}
	
	\umlassoc[geometry=-|-, mult1=1, mult2=*, pos1=0.2, pos2=2.75, align2=top]{Funcionario}{Empresa}
	\end{tikzpicture}
	
	\caption{Associação bidirecional entre \texttt{Empresa} e \texttt{Funcionario}}
	\label{fig:associacao-bidirecional-empresa}
\end{figure}
 

Os trechos de código a seguir mostram a implementação da estrutura de classes apresentada na Figura~\ref{fig:associacao-bidirecional-empresa}. Repare nos atributos que implementam o vínculo bidimensional. Na classe \code{Empresa} temos a lista de funcionários (\code{funcionarios}), enquanto na classe \code{Funcionario} temos o vínculo com a empresa (\code{empresa}). Repare ainda que o método \code{setEmpresa} da classe \code{Funcionario} também realiza a operação de inclusão do funcionário na lista de funcionários da empresa.

\begin{minted}{java}
public class Empresa {
	private String razaoSocial;
	private String nomeFantasia;
	private String cnpj;
	private List<Funcionario> funcionarios;
	
	public void addFuncionario(Funcionario f){
		this.funcionarios.add(f);
	}
}
\end{minted}

\begin{minted}{java}
public class Funcionario {
	private String nome;
	private String cpf;
	private Empresa empresa;
	
	public void setEmpresa(Empresa empresa){
		this.empresa = empresa;
		empresa.addFuncionario(this);
	}
}
\end{minted} 

O código abaixo mostra o uso da estrutura proposta. A atribuição é feita pela chamada do método \code{setEmpresa} (linhas 9 a 11). As linhas 13 a 15 mostram que é possível acessar todos os funcionários da empresa (\code{e1.getFuncionarios()}), bem como acessar os dados da empresa em que um funcionário trabalha (\code{f.getEmpresa().getNomeFantasia()}).

\begin{minted}{java}
public static void main(String[] args) {
	Funcionario f1 = new Funcionario("José da Silva", "012.541.379-33");
	Funcionario f2 = new Funcionario("Maria Pereira", "062.411.632-12");
	Funcionario f3 = new Funcionario("Pedro Ferreira", "178.219.475-25");

	Empresa e1 = new Empresa("Empresa 1 LTDA", "Empresa 1", "123.456.789/0001-01");
	Empresa e2 = new Empresa("Empresa 2 LTDA", "Empresa 2", "123.456.789/0001-02");

	f1.setEmpresa(e1);
	f2.setEmpresa(e1);
	f3.setEmpresa(e2);

	for(Funcionario f : e1.getFuncionarios())
		 System.out.println(f.getNome() + " trabalha na " + f.getEmpresa().getNomeFantasia());
}
\end{minted}


\section{Agregação e composição}

A agregação e a composição são tipos específicos de associações, onde uma entidade forma parte de outra. Logo, a implementação de uma agregação ou de uma composição é idêntica à implementação de uma associação simples\footnote{Em alguns casos são implementadas regras simples na agregação e na composição, como a obrigatoriedade do vínculo ou a garantia de que uma entidade qualquer não seja componente de duas entidades simultaneamente}. Isto é, a diferença entre elas é conceitual.

\subsection{Relacionamento todo-parte}

A agregação e a composição acontecem quando duas entidades possuem um relacionamento todo-parte. Neste relacionamento, uma das entidades forma parte da outra. Por exemplo, uma empresa é composta por departamentos. Os departamentos são partes da empresa. Logo, a entidade \code{Empresa} é chamada ``todo'', enquanto a entidade \code{Departamento} é chamada ``parte''.

Uma instância da classe todo possui uma ou mais instâncias da classe parte. A instância da classe parte complementa as informações da classe todo, de modo que o todo não é completo sem as suas partes. No exemplo da empresa e dos seus departamentos, uma empresa sem departamentos não é completa e os departamentos complementam as informações sobre a empresa. Abaixo são apresentados outros exemplos de entidades que se relacionam como todo-parte.

\begin{itemize}
	\item Um veículo (todo) é composto por quatro rodas (parte).
	\item Um computador (todo) possui um teclado, um mouse e um monitor (partes).
	\item Uma lista de compras (todo) possui uma lista de itens a comprar (parte).
	\item Uma empresa (todo) é composta por departamentos (parte).
	\item Um livro (todo) é composto por capítulos (parte).
	\item Um capítulo do livro (todo) é composto por páginas (parte).
\end{itemize}

Existem algumas características (apresentadas no formato de perguntas) que auxiliam na identificação de um relacionamento todo-parte:

\begin{enumerate}
\item O relacionamento é descrito com uma frase ``parte de''?
	\begin{itemize}
		\item Um \textbf{botão} é parte de uma \textbf{janela}.
		\item A \textbf{porta} é parte de um \textbf{carro}.
	\end{itemize}
	
\item Algumas operações no todo são automaticamente aplicadas a suas partes?
\begin{itemize}
	\item Mover a \textbf{janela} implica em mover o \textbf{botão}.
\end{itemize}

\item Alguns valores de atributos são propagados do todo para todos ou algumas de suas partes?
\begin{itemize}
	\item A fonte da \textbf{janela} é Arial, a fonte do \textbf{botão} é Arial.
	\item Pintar o carro de \textbf{vermelho} implica pintar também a \textbf{porta} de vermelho.
\end{itemize}

\item Existe uma assimetria inerente no relacionamento onde uma classe é subordinada a outra?
\begin{itemize}
	\item Uma \textbf{botão} É parte de uma \textbf{janela}, uma \textbf{janela} NÃO É parte de um \textbf{botão}.
	\item Uma \textbf{porta} É parte de um \textbf{carro}, um \textbf{carro} NÃO É parte de uma \textbf{porta}.
\end{itemize}
\end{enumerate}

Logo, tanto as entidades \textbf{janela} e \textbf{botão}, quanto as entidades \textbf{carro} e \textbf{porta} formam relacionamentos todo-parte.

\subsection{Agregação $\times$ composição}
 
\subsubsection{Agregação}
Existem duas regras que determinam que o relacionamento todo-parte trata-se de uma agregação:

\begin{enumerate}
	\item Ambas as entidades (todo e parte) podem existir de forma independente à outra.
	\item Uma entidade parte pode estar relacionada com mais de uma entidade todo ao mesmo tempo.
\end{enumerate}
 
\textbf{Um exemplo:} uma escola possui vários professores.
\begin{itemize}
	\item Trata-se de uma agregação, pois um professor pode existir fora do relacionamento com a escola.
	\item Trata-se de uma agregação, pois um professor pode trabalhar em duas escolas ao mesmo tempo, ou seja, sua entidade se relaciona com dois objetos diferentes do todo.
\end{itemize}

Na UML, representamos uma agregação com um losango não preenchido no lado da entidade que representa o todo. A Figura~\ref{fig:agregacao-professor-escola} mostra as classes \code{Professor} e \code{Escola} e seu relacionamento de agregação. Repare que a entidade todo recebe o losango do relacionamento.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Escola}{
		-- nome: String \\
		-- cidade: String
	}{
		+ métodos construtores \\
		+ métodos acessores
	}
	
	\umlclass[x=8]{Professor}{
		-- nome: String \\
		-- disciplina: String
	}{
		+ métodos construtores \\
		+ métodos acessores
	}
	
	\umlaggreg[geometry=-|-, align2=top]{Escola}{Professor}
	\end{tikzpicture}
	
	\caption{Relacionamento de agregação entre \texttt{Escola} e \texttt{Professor}}
	\label{fig:agregacao-professor-escola}
\end{figure}

Em geral, o atributo que implementa a agregação fica na entidade todo (apesar de não ser uma regra). Quando a agregação possui multiplicidade 1 no lado parte, ela é implementada por um atributo simples no lado todo. Quando a agregação possui multiplicidade muitos no lado parte, ela é implementada por uma lista de objetos no lado todo.

\subsubsection{Caso com multiplicidade 1}

Um exemplo de agregação com multiplicidade 1 acontece entre as entidades \code{Radar} e \code{SensorVelocidade}. Um radar possui um único sensor de velocidade. O sensor de velocidade fica localizado abaixo da pista e, portanto, existe mesmo fora do relacionamento com o radar e pode estar relacionado com dois ou mais radares ao mesmo tempo (regras para definição de uma agregação). A Figura~\ref{fig:agregacao-radar-sensor} mostra o diagrama de classes para este exemplo.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Radar}{
		-- velocidadeMaxima: double
	}{
		+ métodos construtores \\
		+ métodos acessores
	}
	
	\umlclass[x=8]{SensorVelocidade}{
		-- precisao: double
	}{
		+ métodos construtores \\
		+ métodos acessores
	}
	
	\umlaggreg[geometry=-|-, mult2=1, pos=2.8, align2=top]{Radar}{SensorVelocidade}
	\end{tikzpicture}
	
	\caption{Relacionamento de agregação entre \texttt{Radar} e \texttt{SensorVelocidade}}
	\label{fig:agregacao-radar-sensor}
\end{figure}

Os trechos de código abaixo mostram a implementação das classes apresentadas na Figura~\ref{fig:agregacao-radar-sensor}. Na classe \code{Radar} (entidade todo) o vínculo é implementado pelo atributo \code{sensor}, que é um objeto da entidade parte.

\begin{minted}{java}
public class Radar {
	private double velocidadeMaxima;
	private SensorVelocidade sensor;
	
	public SensorVelocidade getSensor() {
		return sensor;
	}
	
	public void setSensor(SensorVelocidade s){
		this.sensor = s;
	}
}
\end{minted}
 
\begin{minted}{java}
public class SensorVelocidade {
	private double precisao;
	
	public double getPrecisao() {
		return precisao;
	}
	
	public void setPrecisao(double precisao) {
		this.precisao = precisao;
	}
}
\end{minted}

\subsubsection{Caso com multiplicidade muitos}

Um exemplo de agregação com multiplicidade muitos ocorre entre uma turma e seus alunos. Os alunos são parte de uma turma, que é a entidade todo. Os alunos existem independente do relcionamento com a turma e um aluno pode pertencer a duas turmas simultaneamente. Logo, temos um relacionamento de agregação. Neste caso, a turma possui vários alunos, definindo a multiplicidade muitos no lado parte. A Figura~\ref{fig:agregacao-turma-aluno} apresenta a estrutura de classes para este exemplo.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Turma}{
		-- ano: int \\
		-- semestre: int
	}{
		+ métodos construtores \\
		+ métodos acessores
	}
	
	\umlclass[x=8]{Aluno}{
		-- matricula: String \\
		-- nome: String
	}{
		+ métodos construtores \\
		+ métodos acessores
	}
	
	\umlaggreg[geometry=-|-, mult2=*, pos=2.8, align2=top]{Turma}{Aluno}
	\end{tikzpicture}
	
	\caption{Relacionamento de agregação entre \texttt{Turma} e \texttt{Aluno}}
	\label{fig:agregacao-turma-aluno}
\end{figure}
 
Os códigos a seguir mostram a implementação das classes apresentadas na Figura~\ref{fig:agregacao-turma-aluno}. Repare que a agregação é implementada por uma lista na entidade todo. Neste sentido, a classe \code{Turma} possui uma lista de objetos da classe \code{Aluno}. Assim como na associação simples, uma boa prática consiste em definir um método \code{addAluno} para realizar o vínculo entre as duas entidades.

\begin{minted}{java}
public class Turma {
	private int ano;
	private int semestre;
	private List<Aluno> alunos = new ArrayList<Aluno>();
	
	public void addAluno(Aluno a) {
		this.alunos.add(a);
	}
	
	public List<Aluno> getAlunos() {
		return alunos;
	}
	
	public void setAlunos(List<Aluno> alunos){
		this.alunos = alunos;
	}
}
\end{minted}
 
\begin{minted}{java}
public class Aluno {
	private String matricula;
	private String nome;
	
	public String getMatricula() {
		return matricula;
	}

	public void setMatricula(String mat) {
		this.matricula = mat;
	}
}
\end{minted}
 
\subsubsection{Composição}
Existem duas regras que determinam que o relacionamento todo-parte trata-se de uma composição:

\begin{enumerate}
	\item A entidade parte só existe em função do relacionamento que possui com a entidade todo. Caso a entidade todo seja destruída, suas partes também são destruídas.
	\item Uma entidade parte pode estar relacionada com apenas uma entidade todo simultaneamente.
\end{enumerate}

\textbf{Um exemplo:} um veículo possui quatro rodas.
\begin{itemize}
	\item Trata-se de uma composição, pois uma roda não existe sem estar vinculada ao veículo.
	\item Trata-se de uma composição, pois uma roda não pode estar vinculada a dois veículos ao mesmo tempo, sua entidade se relaciona a apenas um objeto todo.
\end{itemize}

Na UML, representamos uma composição com um losango preenchido no lado da entidade que representa o todo. A Figura~\ref{fig:composicao-veiculo-roda} mostra as classes \code{Veiculo} e \code{Roda} e seu relacionamento de composição. Repare que a entidade todo recebe o losango do relacionamento.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Veiculo}{
		-- modelo: String \\
		-- marca: String
	}{
		+ métodos construtores \\
		+ métodos acessores
	}
	
	\umlclass[x=8]{Roda}{
		-- ano: int
	}{
		+ métodos construtores \\
		+ métodos acessores
	}
	
	\umlcompo[geometry=-|-, align2=top]{Escola}{Professor}
	\end{tikzpicture}
	
	\caption{Relacionamento de agregação entre \texttt{Veiculo} e \texttt{Roda}}
	\label{fig:composicao-veiculo-roda}
\end{figure}
 
Da mesma forma como ocorre com a agregação, um relacionamento de composição com multiplicidade 1 na entidade parte é implementado com um atributo simples na classe todo. Um relacionamento de composição com multiplicidade muitos na entidade parte é implementado com uma lista de objetos na classe todo. Diferente da agregação, um objeto da classe parte está associado a apenas um objeto da classe todo (conceito de composição). Logo, a multiplicidade na parte todo é, obrigatoriamente, 1.

\subsubsection{Caso com multiplicidade 1}

Um exemplo de composição com multiplicidade 1 acontece entre as entidades \code{Computador} e \code{Processador}. Um computador possui um único processador. O processador fica localizado dentro do computador e, portanto, não existe fora do relacionamento com o computador e não pode estar relacionado com dois ou mais computadores ao mesmo tempo (regras para definição de uma composição). A Figura~\ref{fig:composicao-computador-processador} mostra o diagrama de classes para este exemplo.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Computador}{
	}{
		+ métodos construtores \\
		+ métodos acessores
	}
	
	\umlclass[x=8]{Processador}{
		-- nucleos: int \\
		-- potencia: double
	}{
		+ métodos construtores \\
		+ métodos acessores
	}
	
	\umlcompo[geometry=-|-, mult2=1, pos=2.8, align2=top]{Computador}{Processador}
	\end{tikzpicture}
	
	\caption{Relacionamento de composição entre \texttt{Computador} e \texttt{Processador}}
	\label{fig:composicao-computador-processador}
\end{figure}

Os trechos de código abaixo mostram a implementação das classes apresentadas na Figura~\ref{fig:composicao-computador-processador}. Na classe \code{Computador} (entidade todo) o vínculo é implementado pelo atributo \code{processador}, que é um objeto da entidade parte. Uma boa prática (mas não uma regra) consiste em não implementar o método \code{setProcessador}, mas sim um método que receba os atributos do processador e instancie um novo objeto para vínculo (linhas 4 a 8). Com isso, evita-se que uma mesma instância da entidade parte seja vinculada a duas ou mais instâncias da entidade todo. No entanto, com isso não se permite que o objeto parte troque seu vínculo para outro objeto todo. Caso seja preciso, deve-se implementar os métodos acessores necessários.

\begin{minted}{java}
public class Computador {
	private Processador processador;

	public void addProcessador(int nucleos, double potencia) {
		processador = new Processador();
		processador.setNucleos(nucleos);
		processador.setPotencia(potencia);
	}
	
	public void removeProcessador() {
		this.processador = null;
	}
}
\end{minted}
 
\begin{minted}{java}
public class Processador {
	private int nucleos;
	private double potencia;
	
	public int getNucleos() {
		return nucleos;
	}

	public void setNucleos(int nucleos) {
		this.nucleos = nucleos;
	}

	public double getPotencia() {
		return potencia;
	}
	
	public void setPotencia(double potencia) {
		this.potencia = potencia;
	}
}
\end{minted}

\subsubsection{Caso com multiplicidade muitos}

Um exemplo de composição com multiplicidade muitos acontece entre as entidades \code{Livro} e \code{Capitulo}. Um livro é composto por vários capítulos. O capítulo é parte de um livro e, portanto, não existe fora do relacionamento. Além disso, um capítulo não deve fazer parte de dois livros ao mesmo tempo. Logo, trata-se de uma composição. A Figura~\ref{fig:composicao-livro-capitulo} mostra o diagrama de classes para este exemplo.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Livro}{
	}{
		+ métodos construtores \\
		+ métodos acessores
	}
	
	\umlclass[x=8]{Capitulo}{
		-- numero: int \\
		-- titulo: String
	}{
		+ métodos construtores \\
		+ métodos acessores
	}
	
	\umlcompo[geometry=-|-, mult2=*, pos=2.8, align2=top]{Livro}{Capitulo}
	\end{tikzpicture}
	
	\caption{Relacionamento de composição entre \texttt{Livro} e \texttt{Capitulo}}
	\label{fig:composicao-livro-capitulo}
\end{figure}

Os trechos de codigo abaixo mostram a implementação da composição apresentada na Figura~\ref{fig:composicao-livro-capitulo}. A composição é definida pela lista de capítulos (atributo \code{caps}) da classe \code{Livro}. Novamente, as operações de criação e vínculo dos caítulos ficam a cargo da classe todo (linhas 4 a 10 da classe \code{Livro}).
 
\begin{minted}{java}
public class Livro {
	private List<Capitulo> caps = new ArrayList<Capitulo>();

	public void addCapitulo(
		int numero, String titulo) {
		Capitulo c = new Capitulo();
		c.setNumero(numero);
		c.setTitulo(titulo);
		caps.add(c);
	}
	
	//demais métodos
}
\end{minted}
 
\begin{minted}{java}
public class Capitulo {
	private int numero;
	private String titulo;

	public int getNumero() {
		return numero;
	}
	
	public void setNumero(int numero) {
		this.numero = numero;
	}
	
	//demais métodos
}
\end{minted}
 
\section{Dependência}

Uma classe \code{A} depende de uma classe \code{B} quando, no momento da compilação da classe \code{A}, o código da classe \code{B} também é compilado. Ou seja, para que a classe \code{A} funcione, é preciso existir (e funcionar) a classe \code{B}. Logo, classes que possuem entre si quaisquer relacionamentos (associação, agregação, composição, especialização) possuem uma dependência.

A dependência é dada pela navegabilidade do relacionamento. Por exemplo, em uma associação a classe que possui um objeto da outra, possui uma dependência com a mesma. Caso a classe independente seja apagada, a classe dependente apresentará erro (ou seja, a classe que implementa o vínculo).

Na orientação a objetos, relacionamentos de diferentes naturezas são representados com diferentes tipos (associação, agregação, composição, etc.). Para os casos onde o relacionamento não se encaixa nos tipos predefinidos, o relacionamento é chamado de dependência. Logo, ele pode ser visto como um relacionamento de utilização, onde os objetos não possuem um vínculo semântico, mas um deles (dependente) faz uso dos serviços do outro (independente). Em geral, uma dependência ocorre quando um \textbf{objeto da outra classe é utilizado como parâmetro ou retorno de um método, ou quando é utilizado internamente pela classe}. As seções a seguir abordam os diferentes casos de dependência através de exemplos.

\subsection{Dependência no argumento de um método}

Considere as entidades \code{Veiculo} e \code{Posto}. Não existe nenhum relacionamento semântico entre estas classes, isto é, elas não são associadas, nem possuem agregação, composição ou herança. No entanto, a classe \code{Veiculo} deve implementar um método chamado \code{abastecer}, no qual recebe combustível (incrementa seu atributo \code{combustivel}) de um posto de gasolina (classe \code{Posto}), que transfere combustível para o referido veículo (decrementa seu atributo \code{estoque}). Perceba que a entidade \code{Veiculo} usa um serviço fornecido pelo objeto da classe \code{Posto}, mas não possui um relacionamento de associação com esta classe. Logo, o relacionamento consiste em uma dependência.

Podemos implementar esta dependência no argumento do método \code{abastecer}, onde o veículo recebe como parâmetro o posto de combustível no qual está abastecendo, além da quantidade desejada de combustível, para então utilizar o serviço de retirada de combustível (implementado pelo método \code{retiraComb} da classe \code{Posto}). Este cenário é descrito pelo diagrama de classes apresentado na Figura~\ref{fig:dependencia-veiculo-posto} e seu código é apresentado na sequência. Observe que a dependencia e representada por uma linha tracejada com ponta de seta para a classe independente.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Veiculo}{
		-- modelo: String \\
		-- placa: String \\
		-- combustivel: double
	}{
		+ abastecer(Posto, double): void
	}
	
	\umlclass[x=8]{Posto}{
		-- nome: String \\
		-- valor: double \\
		-- estoque: double
	}{
		+ retiraComb(double): void
	}
	
	\umldep[geometry=-|-]{Veiculo}{Posto}
	\end{tikzpicture}
	
	\caption{Relacionamento de dependência entre \texttt{Veiculo} e \texttt{Posto}}
	\label{fig:dependencia-veiculo-posto}
\end{figure}

Perceba que o método \code{abastecer} utiliza um objeto da classe \code{Posto} na sua implementação, recebendo-o como argumento. Após isso, a entidade \code{Veiculo} utiliza o serviço implementado pelo método \code{retiraComb} da classe \code{Posto}, capturando seu retorno para o incremento do atributo \code{combustivel}. A classe \code{Posto}, por sua vez, fornece o método \code{retiraComb} que, com base na quantidade recebida como argumento, verifica a possibilidade de abstecimento, decrementando o combustível do seu estoque, em caso positivo. Ao final, o resultado da retirada é devolvido (verdadeiro ou falso).

\begin{minted}{java}
public class Veiculo {
	private String modelo;
	private String placa;
	private double combustivel;
	
	public void abastecer(Posto posto, double qtd) {
		if(posto.retiraComb(qtd))
			this.combustivel += qtd;
	}
	
	//demais métodos
}
\end{minted}

\begin{minted}{java}
public class Posto{
	private String nome;
	private double valor;
	private double estoque;

	public boolean retiraComb(double qtd) {
		if(qtd <= estoque) {
			estoque -= qtd;
			return true;
		}
		return false;
	}
	
	//demais métodos
}
\end{minted}

O relacionamento existente entre as classes \code{Veiculo} e \code{Posto} é de utilização, onde a primeira classe utiliza a segunda. Não existe um vínculo entre as entidades, o que caracteriza a dependência. A classe \code{Veiculo} é dependente da classe \code{Posto}. Observe que a exclusão da classe \code{Posto} implica em erro na classe \code{Veiculo} (pois a última \textbf{depende} da primeira).

\subsection{Dependência no retorno de um método}

Um segundo tipo de dependência ocorre quando o relacionamento de utilização se dá no retorno do método. Um exemplo disso pode ser observado agregando mais uma característica no exemplo anterior. Se quisermos implementar um método que calcule o desempenho do veículo em termos de emissão de poluentes, emissão de ruído e consumo de combustível. Podemos definir uma classe que agregue as diferentes métricas de desempenho. O código abaixo apresenta a implementação da classe \code{Metrica}, que reúne as três medidas supracitadas.

\begin{minted}{java}
public class Metrica {
	private double emissao;
	private double ruido;
	private double consumo;
	
	public double getEmissao() {
		return emissao;
	}
	
	public void setEmissao(double emissao) {
		this.emissao = emissao;
	}
	
	//demais métodos
}
\end{minted}

Diante disso, queremos implementar um método na classe \code{Veiculo} que calcule as medidas de desempenho em função da aceleração. Logo, o método \code{avaliar} recebe como argumento a aceleração praticada e determina os valores de emissão de poluentes, emissão de ruído e consumo de combustível, reunindo-os em um objeto da classe \code{Metrica}, que é devolvido como retorno do método. A Figura~\ref{fig:dependencia-veiculo-posto-metrica} apresenta o diagrama de classes atualizado. Com isso, a classe \code{Veiculo} depende da classe \code{Metrica} pois implementa um método cujo retorno é um objeto desta classe.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Veiculo}{
		-- modelo: String \\
		-- placa: String \\
		-- combustivel: double
	}{
		+ abastecer(Posto, double): void \\
		+ avaliar(double): Metrica
	}
	
	\umlclass[x=8]{Posto}{
		-- nome: String \\
		-- valor: double \\
		-- estoque: double
	}{
		+ retiraComb(double): void
	}
	
	\umlclass[y=5]{Metrica}{
		-- emissao: double \\
		-- ruido: double \\
		-- consumo: double
	}{
	}
	
	\umldep{Veiculo}{Posto}
	\umldep{Veiculo}{Metrica}
	\end{tikzpicture}
	
	\caption{Relacionamento de dependência entre \texttt{Veiculo}, \texttt{Posto} e \texttt{Metrica}}
	\label{fig:dependencia-veiculo-posto-metrica}
	\end{figure}

O trecho de código abaixo mostra a implementação atualizada da classe \code{Veiculo}, incluindo o método \code{avaliar}. De acordo com o valor de aceleração, este método define diferentes valores para as medidas reunidas na classe \code{Metrica}. Ao final, o método devolve um objeto \code{Metrica} com os valores definidos.

\begin{minted}{java}
public class Veiculo {
	private String modelo;
	private String placa;
	private double combustivel;
	
	public void abastecer(Posto posto, double qtd) {
		if(posto.retiraComb(qtd))
			this.combustivel += qtd;
	}
	
	public Metrica avaliar(double aceleracao) {
		Metrica m = new Metrica();
		if(aceleracao <= 10) {
			m.setConsumo(12);
			m.setRuido(41);
			m.setEmissao(340);
		} else {
			m.setConsumo(6);
			m.setRuido(70);
			m.setEmissao(510);
		}
		return m;
	}
	
	//demais métodos
}
\end{minted}

\subsection{Dependência por atributo}

Um terceiro tipo de dependência ocorre quando uma classe utiliza outra como tipo de atributo, mas não caracterizando como um vínculo de associação, agregação ou composição. Por exemplo, uma classe \code{Aplicacao} que mantém uma lista de objetos da classe \code{Aluno}, na qual armazena os registros recuperados de um banco de dados para apresentação em tela. Neste caso, as entidades envolvidas na relação não possuem vínculo semântico, mas a exclusão da classe \code{Aluno} implica em erro na classe \code{Aplicacao}. Logo, ambas as classes possuem uma dependência. A Figura~\ref{fig:dependencia-aplicacao-aluno} apresenta o diagrama de classes para este exemplo, mostrando que a classe \code{Aplicacao} depende da classe \code{Aluno}. Repare que, neste caso, o atributo que define a dependência pode ser representado no diagrama de classes, evidenciando o tipo de dependência existente entre as classes.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Aplicacao}{
		-- alunos: List<Aluno>	
	}{}
	
	\umlclass[x=8]{Aluno}{
		-- nome: String \\
		-- matricula: String \\
		-- fase: int
	}{
		+ métodos construtores
		+ métodos acessores
	}
	
	\umldep{Aplicacao}{Aluno}
	\end{tikzpicture}
	
	\caption{Relacionamento de dependência entre \texttt{Aplicacao} e \texttt{Aluno}}
	\label{fig:dependencia-aplicacao-aluno}
\end{figure}

Os trechos de código abaixo mostram a implementação das classes \code{Aplicacao} e \code{Aluno}. O atributo \code{alunos} define o relacionamento de dependência, conforme apresentado pela Figura~\ref{fig:dependencia-aplicacao-aluno}.

\begin{minted}{java}
public class Aplicacao {
	private List<Aluno> alunos;
	
	public Aplicacao() {
		this.alunos = new ArrayList<Aluno>();
	}
	
	//demais métodos
}
\end{minted}

\begin{minted}{java}
public class Aluno {
	private String nome;
	private String matricula;
	private int fase;
	
	public void setNome(String nome) {
		this.nome = nome;
	}
	
	public String getNome() {
		return this.nome;
	}
	
	//demais métodos
}
\end{minted}

\textbf{OBS:} o termo \textit{dependência por atributo} não é amplamente utilizado, podendo este tipo de dependência ser encontrado com outros nomes na literatura.


\section{Herança e polimorfismo}

\subsection{Herança}

A herança permite definir elementos específicos, que incorporam a estrutura (atributos) e o comportamento (operações) de elementos mais gerais. Neste sentido, a classe específica herda a estrutura e o comportamento da classe geral, definindo uma hierarquia entre elas. Por conta disso, a herança é também chamada de especialização ou generalização. Com o uso da herança é possível reduzir a escrita de código, diminuindo a redundância e agregando flexibilidade e manutenibilidade ao projeto. Na UML, a herança é representada por uma linha sólida contendo um triângulo no lado da classe mais geral, conforme exemplificado na Figura~\ref{fig:exemplo-heranca-uml}.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlemptyclass{ClasseA}
	\umlemptyclass[y=-3]{ClasseB}	
	\umlinherit{ClasseB}{ClasseA}
	\end{tikzpicture}
	
	\caption{Representação UML de uma herança}
	\label{fig:exemplo-heranca-uml}
\end{figure}

Consideremos o contexto de uma empresa a qual possui funcionários e gerentes. Estas entidades são modeladas pelas classes \code{Funcionario} e \code{Gerente}. Todo o funcionário da empresa possui uma matrícula e um salário, inclusive os gerentes. Porém, cada gerente possui um número de subordinados e uma senha para acesso ao sistema. Os trechos de código a seguir mostram a implementação das classes \code{Funcionario} e \code{Gerente}.
 
\begin{minted}{java}
public class Funcionario {
	private String matricula;
	private double salario;

	//...
}
\end{minted}
 
\begin{minted}{java}
public class Gerente {
	private String matricula;
	private double salario;
	private int subordinados;
	private int senha;
	
	//...
}
\end{minted}
 
Podemos perceber que há redundância de código, pois ambas as classes definem os atributos \code{matricula} e \code{salario} (linhas 2 e 3 nas duas classes). E se forem incluídos outros tipos de funcionários (secretária, diretor, presidente)? Neste caso, o código deverá ser replicado nas novas classes. E se, após criados os funcionários, seus atributos tiverem que ser alterados? Então cada classe deverá ser alterada. Ou seja, a estrutura adotada não é flexível nem manutenível, o que leva a um software de baixa qualidade.

A solução para este problema está na utilização de herança, de modo que uma classe geral define a estrutura e o comportamento básicos de um funcionário, enquanto classes específicas herdam estas características e adicionam o necessário para cada tipo de funcionário. Neste sentido, a classe \code{Funcionario} passa a ser a classe geral, definindo os atributos \code{matricula} e \code{salario} enquanto a classe \code{Gerente} herda estes atributos e adiciona os atributos específicos de um gerente, isto é, \code{subordinados} e \code{senha}. A estrutura das classes utilizando herança é apresentada pela Figura~\ref{fig:heranca-funcionario-gerente}.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Funcionario}{
		-- matricula: String \\
		-- salario: double
	}{}
	
	\umlclass[y=-3.5]{Gerente}	{
		-- subordinados: int \\
		-- senha: int
	}{}
	
	\umlinherit{Gerente}{Funcionario}
	\end{tikzpicture}
	
	\caption{Relacionamento de herança entre \texttt{Funcionario} e \texttt{Gerente}}
	\label{fig:heranca-funcionario-gerente}
\end{figure}

Uma herança define um relacionamento do tipo \textbf{É UM}. Neste caso, um gerente \textbf{É UM} funcionário (ou então, um gerente \textbf{É UM TIPO DE} funcionário). Repare que o contrário não é verdadeiro, isto é, um funcionário \textbf{NÃO É UM} gerente (não necessariamente). Quando lemos o relcionamento da classe mais geral para a mais específica, chamamos de especialização: \textit{um gerente é uma especialização de um funcionário}. Quando lemos o relacionamento da classe mais específica para a mais geral, chamamos de generalização: \textit{um funcionário é uma generalização de um gerente}. A classe geral recebe o nome de \textbf{superclasse} ou \textbf{classe-mãe} (neste caso, a classe \code{Funcionario}), enquanto a classe específica recebe o nome de \textbf{subclasse} ou \textbf{classe-filha} (neste caso, a classe \code{Gerente}).

Os trechos de código abaixo mostram a implementação das classes usando herança, conforme proposto na Figura~\ref{fig:heranca-funcionario-gerente}. A implementação de uma herança é feita utilizando a palavra reservada \code{extends}, onde se define que a classe específica estende a classe geral. Neste caso, \code{Gerente} estende um \code{Funcionario}, pois herda suas características e inclui características adicionais.

\begin{minted}{java}
public class Funcionario {
	private String matricula;
	private double salario;
	
	//...
}
\end{minted}
 
\begin{minted}{java}
public class Gerente extends Funcionario {
	private int subordinados;
	private int senha;
	
	//...
}
\end{minted}

O trecho de código a seguir mostra o uso da estrutura de classes criada. Um objeto da classe \code{Gerente} tem acesso a tudo que for público na classe \code{Funcionario}. Porém, um objeto da classe \code{Funcionario} não herda nada da classe \code{Gerente}. Perceba que o objeto \code{g} acessa os métodos acessores dos atributos \code{matricula} e \code{salario} (linhas 3 e 4), os quais são implementados pela classe \code{Funcionario} e herdados no relacionamento de herança.

\textbf{OBS:} Apesar da classe \code{Gerente} herdar os atributos de \code{Funcionario}, ela não pode acessá-los diretamente, pois são privados (o acesso é feito pelo método acessor correspondente). Uma solução para isso seria utilizar outro modificador de acesso: o \code{protected} -- protegido.

\begin{minted}{java}
public static void main(String[] args) {
	Gerente g = new Gerente();
	g.setMatricula("123456");
	g.setSalario(4500);
	g.setSubordinados(10);
	g.setSenha(1234);
}
\end{minted}
 
A estrutura proposta (e apresentada na Figura~\ref{fig:heranca-funcionario-gerente}) pode crescer, de modo a incluir diferentes tipos de funcionários. Neste caso, cada novo tipo de funcionário é implementado por uma nova classe que herda as características da classe \code{Funcionario}. Com isso, caso no futuro o atributo matrícula seja alterado para um número de registro do tipo \code{int}, a alteração afetará somente a classe \code{Funcionario}. Todos os demais tipos de funcionários passam a herdar as novas caracetrísticas, sem necessidade de alteração do código em diferentes pontos do sistema (isso significa flexibilidade e manutenibilidade). A Figura~\ref{fig:heranca-funcionario-varios} mostra este cenário, com diferentes tipos de funcionário se relacionando com a classe \code{Funcionario} por meio de herança.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlemptyclass{Funcionario}
	\umlemptyclass[x=-4.25,y=-3.5]{Gerente}
	\umlemptyclass[x=-1.5,y=-3.5]{Diretor}
	\umlemptyclass[x=1.5,y=-3.5]{Presidente}
	\umlemptyclass[x=4.75,y=-3.5]{Secretaria}
	
	\umlinherit[geometry=|-|]{Gerente}{Funcionario}
	\umlinherit[geometry=|-|]{Diretor}{Funcionario}
	\umlinherit[geometry=|-|]{Presidente}{Funcionario}
	\umlinherit[geometry=|-|]{Secretaria}{Funcionario}
	\end{tikzpicture}
	
	\caption{Estrutura de classes herdando as características de \texttt{Funcionario}}
	\label{fig:heranca-funcionario-varios}
\end{figure}
 

\subsection{Sobrescrita de método}

Consideremos a situação onde todos os funcionários da empresa têm direito a uma gratificação de natal, que consiste em 50\% do seu salário. Logo, podemos implementar o método que determina a gratificação na classe \code{Funcionario}, pois todos os funcionários têm direito a ela. Os códigos a seguir mostram a implementação deste método. 
 
\begin{minted}{java}
public class Funcionario {
	private String matricula;
	private double salario;

	public double gratificacao() {
		return this.salario * 0.5;
	}

	//...
}
\end{minted}
 
\begin{minted}{java}
public class Gerente extends Funcionario {
	private int subordinados;
	private int senha;

	//...
}
\end{minted}
 
Repare que o método \code{gratificacao}, sendo público, também é herdado pelas subclasses de \code{Funcionario}. Com isso, a classe \code{Gerente} herda este método e um objeto desta classe é capaz de chamá-lo. Esta situação é apresentada no código a seguir, que imprimirá em tela o valor de \code{2250.0}, que consiste em 50\% do salário do gerente criado.
 
\begin{minted}{java}
public static void main(String[] args) {
	Gerente g = new Gerente();
	g.setMatricula("123456");
	g.setSalario(4500);
	g.setSubordinados(10);
	g.setSenha(1234);
	System.out.println(g.gratificacao()); //Imprimirá 2250.0
}
\end{minted}
 
 
Consideremos agora que a empresa decida conceder aos gerentes da empresa uma gratificação diferenciada, dado o fato de ser um cargo de confiança. Agora, a gratificação dos gerentes passa a ser 75\% do seu salário. Como resolver este problema?

\textbf{Opção 1:} criar um segundo método chamado \code{gratificacaoGerente}.
\begin{itemize}
	\item \textbf{Problema 1:} a classe \code{Gerente} possuirá dois métodos de gratificação, deixando-a confusa e permitindo a chamada do método errado.
	\item \textbf{Problema 2:} caso a gratificação do diretor seja diferente, um terceiro método deve ser criado, e assim sucessivamente.
\end{itemize}

\textbf{Opção 2 (melhor opção):} reescrever o método \code{gratificacao} na classe \code{Gerente}.
\begin{itemize}
	\item Isso é sobrescrita de métodos!
\end{itemize}

Os trechos de código abaixo mostram a implementação da sobrescrita do método \code{gratificacao}. Agora, a classe \code{Funcionario} possui uma implementação do referido método, enquanto a classe \code{Gerente} possui uma implementação diferente. Todo o objeto da classe \code{Funcionario} executará o método \code{gratificacao} da sua classe e todo o objeto da classe \code{Gerente} executará o método \code{gratificacao} da sua classe.

\textbf{OBS: } uma boa prática é utilizar a anotação \code{@Override}, indicando que o método foi sobrescrito da sua superclasse.

\begin{minted}{java}
public class Funcionario {
	private String matricula;
	private double salario;
	
	public double gratificacao() {
		return this.salario * 0.5;
	}
	
	//...
}
\end{minted}
 
\begin{minted}{java}
public class Gerente extends Funcionario {
	private int subordinados;
	private int senha;

	@Override
	public double gratificacao() {
		return this.getSalario() * 0.75;
	}

	//...
}
\end{minted}
 
O trecho de código abaixo mostra o uso da estrutura de classes criada acima, onde um objeto \code{Gerente} e um objeto \code{Funcionario} são criados. Ao chamar o método \code{gratificacao} do gerente, 75\% do salário é impresso em tela. Ao fazer o mesmo com o funcionário, 50\% do salário é impresso em tela. Ou seja, cada objeto executa o método implementado na sua classe.

\textbf{OBS:} caso o objeto não tivesse implementação do método na sua classe, ele executaria a implementação herdada, isto é, a implementação definida na classe \code{Funcionario}.

\begin{minted}{java}
public static void main(String [] args) {
	Gerente g = new Gerente();
	g.setSalario(1000);
	
	Funcionario f = new Funcionario();
	f.setSalario(1000);
	
	System.out.println(g.gratificacao());  //imprimirá 750.0
	System.out.println(f.gratificacao());  //imprimirá 500.0
}
\end{minted}
 
Neste ponto, se quisermos incluir um novo tipo de funcionário, basta criarmos a classe para o novo tipo e herdarmos as características de \code{Funcionario}. Isso faz com que o novo tipo de funcionário herde os atributos e também o método \code{gratificacao}. Caso queiramos que a gratificação para este novo tipo de funcionário seja diferenciada, basta sobrescrevermos o método \code{gratificacao} (novamente, flexibilidade e manutenibilidade).

Consideremos agora um novo cenário: a gratificação concedida aos gerentes deve ser igual àquela concedida aos funcionários, com um acréscimo de R\$500,00. Uma solução para este novo cenário consiste em implementar a gratificação de 50\% do salário, mais o adicional de R\$500,00 (ou seja, copiar a implementação da classe funcionário, somando ainda o valor adicional). O trecho de código a seguir mostra a implementação do referido método.

\begin{minted}{java}
@Override
public double gratificacao() {
	return this.getSalario() * 0.5 + 500;
}
\end{minted}

No entanto, se a gratificação dos funcionários for alterada (para 60\%, por exemplo), o método da classe \code{Gerente} também deverá ser alterado. Ou seja, uma mudança que exige alteração do código em dois pontos. O mesmo pode ocorrer ainda com diferentes tipos de funcionário.

Uma solução mais adequada consiste em chamar o método \code{gratificaca} da superclasse (\code{Funcionario}) e acrescentar os R\$500,00. O acesso à superclasse é feito através da cláusula \code{super}, que devolve a instância da superclasse da herança, permitindo a execução do método implementado nela. Neste caso, permitindo a chamada do método \code{gratificacao} da classe \code{Funcionario}. O trecho de código abaixo mostra este exemplo.

\begin{minted}{java}
@Override
public double gratificacao() {
	return super.gratificacao() + 500;
}
\end{minted}

Com isso, caso a gratificação dos funcionários seja alterada, apenas o código da classe \code{Funcionario} terá de ser alterado. Sempre que a subclasse deve fazer \textbf{``algo a mais''} em relação à implementação da superclasse, esta técnica deve ser aplicada, garantindo (mais uma vez) a flexibilidade e a manutenibilidade.


\subsection{Polimorfismo}
 
Na herança desenvolvida nas seções anteriores, um gerente \textbf{É UM} funcionário. Se uma emissora de televisão fizer um convite para que um dos funcionários da empresa conceda uma entrevista, um gerente poderá fazê-lo, pois o gerente é um funcionário. Uma variável do tipo \code{Funcionario} armazena uma referência a um \code{Funcionario}. Logo, ela pode armazenar uma referência a um \code{Gerente}, pois este é um \code{Funcionario}. O trecho de código abaixo exemplifica esta possibilidade.

\begin{minted}{java}
Gerente g1 = new Gerente();
Funcionario f1 = g1;
Funcionario f2 = new Gerente();
\end{minted}

\textbf{Polimorfismo} é, portanto, a capacidade de um objeto poder ser referenciado de várias formas. No exemplo anterior, o objeto \code{f1} pode armazenar uma referência a um objeto da classe \code{Funcionario} ou uma referência a um objeto da classe \code{Gerente}. Se tivéssemos mais classes estendendo \code{Funcionario}, ele poderia armazenar uma referência a um objeto de qualquer uma dessas classes (várias formas -- polimorfismo).

Considerando um objeto do tipo \code{Funcionario} armazenando uma referência a um objeto da classe \code{Gerente}. Ao chamar o método \code{gratificacao} (sobrescrito na classe \code{Gerente}), qual das implementações será executada? Considere que \code{Funcionario} implementa uma gratificação de 50\% e \code{Gerente} implementa uma gratificação de 75\%.

\begin{minted}{java}
Funcionario f = new Gerente();
f.setSalario(1000);
System.out.println(f.gratificacao());
\end{minted}

\textbf{Resposta: } a decisão sobre qual método executar é feito em tempo de execução. O Java verifica qual a classe do objeto que está sendo referenciado dentro da variável e executa o respectivo método. Neste caso, executará o método implementado na classe \code{Gerente} (que é a classe da referência armazenada em \code{f}), imprimindo o valor de \code{750.0}.

O polimorfismo é especialmente útil se quisermos definir um método genérico para todos os funcionários, independente do seu tipo (gerente, diretor, secretária, etc.). A classe apresentada no código abaixo tem a responsabilidade de controlar o total de gratificações concedidas. O método \code{registro} recebe um funcionário e computa a gratificação do mesmo, armazenando a soma total no atributo \code{totalGratificacoes}.

\begin{minted}{java}
public class ControleGratificacoes {
	private double totalGratificacoes = 0;

	public void registro(Funcionario f) {
		this.totalGratificacoes += f.gratificacao();
	}

	public double getTotalGratificacoes() {
		return this.totalGratificacoes;
	}
}
\end{minted}

O método \code{registro} recebe uma referência a um \code{Funcionario}, chamando seu método \code{gratificacao}. Logo, ele pode receber referências a qualquer classe que estende \code{Funcionario}, verificando a referência recebida e chamando o método correto. Ou seja, não importa se o objeto recebido seja um gerente ou uma secretária, o método funcionará de qualquer forma. Mais do que isso, se incluído um novo tipo de funcionário, o método \code{registro} não precisa ser alterado, pois é genérico para qualquer tipo de funcionário (desde que, claro, estenda a classe \code{Funcionario}).

\subsection{Exemplo -- Veículos}
Considere duas entidades: carro e moto. Um carro possui uma marca, um modelo, uma cor, um valor e um número de portas. Uma moto possui uma marca, um modelo, uma cor, um valor e uma quantidade de cilindradas. Como as classes possuem replicação de código, podemos definir uma classe geral e estendê-la nas classes \code{Carro} e \code{Moto}.

Além dos atributos, estas duas entidades possuem em comum um método para cálculo do seu imposto, que corresponde a 2\% do seu valor. Especificamente para carros, é acrescido R\$\,800,00 ao seu imposto.

\subsubsection{Estrutura das classes}

A Figura~\ref{fig:exemplo-carro-moto} mostra a estrutura das classes envolvidas no exemplo. A classe \code{Veiculo} define as características gerais de um veículo (marca, modelo cor e valor), bem como o método para cálculo do imposto. As classes \code{Carro} e \code{Moto} herdam os atributos e métodos da classe \code{Veiculo}, adicionando suas particularidades (quantidade de portas e cilindradas), assim como sobrescrevendo o método para cálculo do imposto, no caso dos carros.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Veiculo}{
		-- marca: String \\
		-- modelo: String \\
		-- cor: String \\
		-- valor: double
	}{
		+ calculaImposto(): double
	}
	
	\umlclass[x=-3,y=-5]{Carro}	{
		-- qtdPortas: int
	}{
		+ calculaImposto(): double
	}
	
	\umlclass[x=3,y=-5]{Moto}	{
		-- cilindradas: int
	}{}
	
	\umlinherit[geometry=|-|]{Carro}{Veiculo}
	\umlinherit[geometry=|-|]{Moto}{Veiculo}
	\end{tikzpicture}
	
	\caption{Estrutura de classes para o exemplo dos veículos}
	\label{fig:exemplo-carro-moto}
\end{figure}

\subsubsection{Implementação das entidades}

\subsubsection{Classe \texttt{Veiculo}}

O código abaixo mostra a implementação da classe \code{Veiculo}, que desempenha o papel da superclasse no exemplo. Esta classe define os atributos comuns de todos os veículos (linhas 2 a 5) e a implementação do método comum a todos os veículos (\code{valculaImposto}), o qual define o valor do imposto como 2\% do valor do veículo.

\begin{minted}{java}
public class Veiculo {
	private String marca;
	private String modelo;
	private String cor;
	private double valor;
	
	public double calculaImposto() {
		return this.valor * 0.02;
	}
	
	public Veiculo() {}
	
	public Veiculo(String marca, String modelo, String cor, double valor) {
		this.marca = marca;
		this.modelo = modelo;
		this.cor = cor;
		this.valor = valor;
	}
	
	//Métodos acessores
}
\end{minted}

\subsubsection{Classe \texttt{Carro}}

O código abaixo mostra a implementação da classe \code{Carro}, que herda a estrutura e o comportamento da classe \code{Veiculo} (linha 1) e define suas características específicas, como o atributo \code{numPortas}. Além disso, esta classe sobrescreve o método \code{calculaImposto}, adicionando o valor fixo de R\$\,800,00. Neste caso, o método faz a chamada do cálculo do imposto da superclasse (através do \code{super}) e adiciona um comportamento adicional.

Observe que a mesma característica é observada no método construtor, onde o construtor da superclasse é chamado (linhas 10 e 14) com seus respectivos parâmetros, para então atribuir suas características específicas. Esta é uma boa prática, pois garante que modificações no construtor da superclasse não resultem em alterações nas subclasses.

\begin{minted}{java}
public class Carro extends Veiculo {
	private int numPortas;

	@Override
	public double calculaImposto() {
		return super.calculaImposto() + 800;
	}

	public Carro() {
		super();
	}

	public Carro(int numPortas, String marca, String modelo, String cor, double valor) {
		super(marca, modelo, cor, valor);
		this.numPortas = numPortas;
	}

	//Métodos acessores
}
\end{minted}

\subsubsection{Classe \texttt{Moto}}

O código a seguir mostra a implementação da classe \code{Moto}, que também herda as características da classe \code{Veiculo} e adiciona um atributo específico (\code{cilindradas}). Neste caso, o cálculo do imposto para uma moto é igual ao cálculo geral. Por isso, não é necessária a sobrescrita do método \code{calculaImposto} nesta classe.

\begin{minted}{java}
public class Moto extends Veiculo {
	private int cilindradas;

	public Moto() {
		super();
	}

	public Moto(int cilindradas, String marca, String modelo, String cor, double valor) {
		super(marca, modelo, cor, valor);
		this.cilindradas = cilindradas;
	}

	//Métodos acessores
}
\end{minted}

\subsubsection{Uso das classes}

Deseja-se implementar os seguintes métodos:
\begin{itemize}
	\item Criação de registros de carros e motos e armazenamento em uma lista polimórfica.
	\item Verificação de veículos de uma determinada marca.
	\item Apresentação dos veículos e seus valores de impostos.
	\item Apresentação de todos os carros da lista.
\end{itemize}

Para isso, criaremos uma classe \code{Aplicacao}, responsável por armazenar a lista de veículos (objetos da classe \code{Veiculo} e, portanto, polimórfica) e implementar os métodos desejados. A Figura~\ref{fig:exemplo-carro-moto-aplicacao} mostra a estrutura de classes atualizada e o trecho de código da sequência apresenta a estrutura básica da classe aplicação.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlclass{Veiculo}{
		-- marca: String \\
		-- modelo: String \\
		-- cor: String \\
		-- valor: double
	}{
		+ calculaImposto(): double
	}
	
	\umlclass[x=-3,y=-5]{Carro}	{
		-- qtdPortas: int
	}{
		+ calculaImposto(): double
	}
	
	\umlclass[x=3,y=-5]{Moto}	{
		-- cilindradas: int
	}{}
	
	\umlemptyclass[x=-6]{Aplicacao}
	
	\umlinherit[geometry=|-|]{Carro}{Veiculo}
	\umlinherit[geometry=|-|]{Moto}{Veiculo}
	\umldep{Aplicacao}{Veiculo}
	\end{tikzpicture}
	
	\caption{Estrutura de classes atualizada para o exemplo dos veículos}
	\label{fig:exemplo-carro-moto-aplicacao}
\end{figure}

\begin{minted}{java}
public class Aplicacao {
	private List<Veiculo> veiculos = new ArrayList<Veiculo>();
	
	private void criaRegistros() {
		// implementação omitida
	}
	
	private void veiculosDaMarca(String marca) {
		// implementação omitida
	}
	
	private void mostraImpostos() {
		// implementação omitida
	}
	
	private void mostraCarros() {
		// implementação omitida
	}
}
\end{minted}

\subsubsection{Criação dos registros}

O código abaixo mostra a implementação do método \code{criaRegistros}. São criados objetos do tipo \code{Carro} e \code{Moto} e adicionados na mesma lista (\code{veiculos}). Isso funciona pois a lista é de objetos da classe \code{Veiculo} (\code{List<Veiculo>}), que permite armazenar referências a qualquer classe que estenda \code{Veiculo}, que é o caso das classes \code{Carro} e \code{Moto}. Por conta disso, dizemos que a lista é polimórfica.

\begin{minted}{java}
private void criaRegistros() {
	Carro c1= new Carro(2, "VW", "Gol", "prata", 25000);
	Carro c2 = new Carro(4, "Fiat", "Uno", "branco", 20000);
	Carro c3= new Carro(4, "Renault", "Clio", "preto", 32000);
	Carro c4= new Carro(2, "Fiat", "147", "amarelo", 8000);

	Moto m1 = new Moto(150, "Honda", "CG", "azul", 7000);
	Moto m2 = new Moto(150, "Yamaha", "YBR", "vermelho", 12000);

	veiculos.add(c1);
	veiculos.add(c2);
	veiculos.add(c3);
	veiculos.add(c4);
	veiculos.add(m1);
	veiculos.add(m2);
}
\end{minted}

\subsubsection{Consulta de veículos de uma marca}

O código abaixo mostra a implementação do método \code{veiculosDaMarca}. Nele, a lista de veículos é percorrida, independente da referência que se encontra a cada iteração (linha 3). Pela herança, é garantido que todos os objetos dessa lista possuam o método \code{getMarca}, que é utilizado para filtrar os registros e apresentar, ao final, a quantidade de veículos da marca recebida como parâmetro.

\begin{minted}{java}
private void veiculosDaMarca(String marca) {
	int qtd = 0;
	for(Veiculo v: veiculos) {
		if(v.getMarca().equals(marca))
		qtd++;
	}
	JOptionPane.showMessageDialog(null, "A marca " + marca + " possui " + qtd + " veículos!");
}
\end{minted}

\begin{minipage}{\textwidth}
	\textbf{\texttt{SAÍDA:}}\\
	\texttt{A marca VW possui 1 veículos!}\\
	\texttt{A marca Fiat possui 2 veículos!}\\
	\texttt{A marca Renault possui 1 veículos!}\\
	\texttt{A marca Honda possui 1 veículos!}\\
	\texttt{A marca Yamaha possui 1 veículos!}
\end{minipage}

\subsubsection{Apresentação dos impostos}

O código abaixo mostra a implementação do método \code{mostraImpostos}. Em tempo de execução, o Java verifica qual a referência armazenada em \code{v} e executa o respectivo método \code{calculaImposto}. Ou seja, é executado o método implementado em \code{Veiculo} ou em \code{Carro}.

\begin{minted}{java}
private void mostraImpostos() {
	String texto = "";
	for(Veiculo v : veiculos) {
		texto += v.getMarca() + " " + v.getModelo() + "(" + v.getValor() + "): " + v.calculaImposto() + "\n";
	}
	JOptionPane.showMessageDialog(null, texto);
}
\end{minted}

\begin{minipage}{\textwidth}
	\textbf{\texttt{SAÍDA:}}\\
	\texttt{VW Gol (25000.0): 1300.0}\\
	\texttt{Fiat Uno (20000.0): 1200.0}\\
	\texttt{Renault Clio (32000.0): 1440.0}\\
	\texttt{Fiat 147 (8000.0): 960.0}\\
	\texttt{Honda CG (7000.0): 140.0}\\
	\texttt{Yamaha YBR (12000.0): 240.0}
\end{minipage}

\subsubsection{Apresentação dos carros}

O código abaixo mostra a implementação do método \code{mostraCarros}. A lista é percorrida e a classe da referência armazenada em cada posição é verificada pelo método \code{instanceOf}. Este comando verifica se o objeto (à esquerda) é do tipo da classe desejada (à direita), retornando verdadeiro ou falso.

\begin{minted}{java}
private void mostraCarros() {
	String texto = "";
	for(Veiculo v: veiculos) {
		if(v instanceof Carro)
		texto += v.getMarca() + " " + v.getModelo() + ", cor " + v.getCor() + "\n";
	}
	JOptionPane.showMessageDialog(null, texto);
}
\end{minted}

\begin{minipage}{\textwidth}
	\textbf{\texttt{SAÍDA:}}\\
	\texttt{VW Gol, cor prata}\\
	\texttt{Fiat Uno, cor branco}\\
	\texttt{Renault Clio, cor preto}\\
	\texttt{Fiat 147, cor amarelo}
\end{minipage}


\section{Classes abstratas}

\subsection{Conceitos e benefícios}

O maior benefício oriundo da generalização/especialização de classes através da herança é o \textbf{polimorfismo}. Ele é um recurso poderoso, capaz de garantir ao sistema flexibilidade. Para estudar o conceito de classes abstratas e sua relação com o polimorfismo, consideremos um contexto de figuras geométricas, as quais compartilham entre si uma cor e possuem métodos para cálculo da sua área e do seu perímetro. A Figura~\ref{fig:abstratas-figuras} apresenta a estrutura de classes onde diferentes figuras geométricas herdam as características da classe \code{Figura}.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlemptyclass{Figura}
	\umlemptyclass[x=-3,y=-3.5]{Retangulo}
	\umlemptyclass[y=-3.5]{Triangulo}
	\umlemptyclass[x=2.75,y=-3.5]{Circulo}
	
	\umlinherit[geometry=|-]{Retangulo}{Figura}
	\umlinherit{Triangulo}{Figura}
	\umlinherit[geometry=|-]{Circulo}{Figura}
	\end{tikzpicture}
	
	\caption{Estrutura de classes para a modelagem de figuras geométricas}
	\label{fig:abstratas-figuras}
\end{figure}

Os trechos de código a seguir mostram a implementação das classes \code{Figura} e \code{Retangulo}, envolvidas no diagrama apresentado pela Figura~\ref{fig:abstratas-figuras}. A classe \code{Figura} define o atributo \code{cor} e os métodos \code{area} e \code{perimetro}, que serão herdados pelas subclasses. A classe \code{Retangulo} implementa alguns atributos adicionais, além de sobrescrever os métodos \code{area} e \code{perimetro}.

\begin{minted}{java}
public class Figura {
	private String cor;
	
	public double area() {
		return 0;
	}
	
	public double perimetro() {
		return 0;
	}
}
\end{minted}

\begin{minted}{java}
public class Retangulo extends Figura {
	private double lado1, lado2;
	
	public double area() {
		return lado1 * lado2;
	}

	public double perimetro() {
		return (lado1 * 2) + (lado2 * 2);
	}
}
\end{minted}

Neste exemplo, não faz sentido termos uma instância da classe \code{Figura}, pois uma figura é sempre um triângulo, um retângulo, um círculo, um trapézio, etc. A classe \code{Figura} define uma entidade abstrata, que só existe para definir uma estrutura comum a todas as figuras concretas, além de estabelecer os métodos que todas devem apresentar (cálculo da área e do trapézio).

Tecnicamente, usamos a classe \code{Figura} para garantir a estrutura e o comportamento de todas as figuras e para nos fornecer polimorfismo. Não faz sentido termos uma instância de \code{Figura} e calcularmos sua área ou perímetro, por exemplo.

Uma dica para identificar casos onde não faz sentido termos uma instância da superclasse é analisar seus métodos. Quando não é possível definir sua implementação, é um bom indicativo de que a classe não deve ser instanciada.

No exemplo das figuras geométricas, cada classe concreta (\code{Triangulo}, \code{Retangulo}, etc.) possui sua própria forma de calcular a área e o perímetro em função dos seus atributos. Isso não acontece na classe \code{Figura}, que é incapaz de prover uma implementação dos métodos supracitados.

Nestes casos, podemos definir a classe como \textbf{abstrata}, o que implica na impossibilidade de ser instanciada. Com isso, a classe se restringe a definir a estrutura e o comportamento das classes que a estenderem e fornecer polimorfismo.

Por exemplo, se tivermos uma lista de figuras (\code{List<Figura>}) estamos fazendo uso do polimorfismo. Caso a classe \code{Figura} seja abstrata, temos a garantia de que todos os objetos da lista são figuras concretas (triângulos, retângulos, etc.) e, com isso, faz sentido chamarmos os métodos \code{area} e \code{perimetro} para qualquer um deles.

\subsection{Implementação}

A palavra reservada \code{abstract} define uma classe como abstrata. O trecho de código abaixo mostra a definição da classe \code{Figura} como abstrata. Com isso, não é possível instanciar objetos dessa classe. O comando \code{Figura f = new Figura()} não compilará, enquanto o comando \code{Figura f = new Circulo()} continua funcionando normalmente.

\begin{minted}{java}
public abstract class Figura {
	private String cor;

	public double area() {
		return 0;
	}
	
	public double perimetro() {
		return 0;
	}
}
\end{minted}

No diagrama de classes, as classes abstratas devem ser representadas como tal, para que esta característica fique facilmente visível. Isso pode ser feito mantendo o nome da classe em itálico (ou ainda adicionando o estereótipo \texttt{<<abstract>>} à classe), conforme apresentado na Figura~\ref{fig:abstratas-figuras-abstract}.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlemptyclass[type=abstract]{Figura}
	\umlemptyclass[x=-3,y=-3.5]{Retangulo}
	\umlemptyclass[y=-3.5]{Triangulo}
	\umlemptyclass[x=2.75,y=-3.5]{Circulo}
	
	\umlinherit[geometry=|-]{Retangulo}{Figura}
	\umlinherit{Triangulo}{Figura}
	\umlinherit[geometry=|-]{Circulo}{Figura}
	\end{tikzpicture}
	
	\caption{Estrutura de classes para a modelagem de figuras geométricas com abstração}
	\label{fig:abstratas-figuras-abstract}
\end{figure}

\subsection{Métodos abstratos}

Resolvemos o problema de não fazer sentido termos uma instância da classe \code{Figura}. Porém, a implementação padrão dos métodos \code{area} e \code{perimetro} ainda não fazem sentido na classe \code{Figura}, uma vez que trata-se de uma entidade abstrata. O ideal seria não haver implementação do método, uma vez que não faz sentido. Além disso, também seria ideal exigir que as subclasses implementem o método, uma vez que a implementação padrão não faz sentido para qualqer classe concreta.

Isso é possível definindo os métodos supracitados como abstratos. Com isso, apenas a assinatura do método é definida na superclasse, exigindo que as subclasses os implementem. Com isso, ao obtermos um objeto do tipo \code{Figura}, sabemos que ele é uma referência a um dos tipos concretos e que os métodos \code{area} e \code{perimetro} estão disponíveis (e fazem sentido).

Para definir um método abstrato, basta inserir a palavra \code{abstract} na sua assinatura e omitir sua implementação, colocando ponto-e-vírgula após o fechamento de parêntesis. O trecho de código abaixo mostra a implementação da classe \code{Figura} com a definição dos métodos abstratos. Logicamente, a classe abstrata poderia definir algum método com implementação padrão às suas subclasses, caso isso fizesse sentido (ocorre em outros contextos).

\begin{minted}{java}
public abstract class Figura {
	private String cor;
	public abstract double area();
	public abstract double perimetro();
}
\end{minted}

É importante destacar que somente é possível definir um método como abstrato, caso ele pertence a uma classe abstrata. Classes concretas não podem conter métodos abstratos e devem implementar todos os métodos abstratos herdados. Uma classe abstrata pode definir métodos abstratos e métodos concretos simultaneamente.

\section{Realização}

\subsection{Interfaces}

Uma interface define um contrato ao qual uma classe pode assinar. Este contrato estabelece todos os métodos que esta classe deverá implementar e fornecer aos seus clientes. Quando uma classe assina o contrato (implementa a interface) deve implementar todos os métodos definidos nele.

Considerando o contexto de figuras geométricas apresentado pela Figura~\ref{fig:realizacao-figuras}, a classe abstrata \code{Figura} define o atributo \code{cor} e os métodos \code{area} e \code{perimetro}. Se for necessário que cada figura implemente seu próprio método \code{desenhar}, uma boa estratégia consiste em definir o método abstrato \code{desenhar} na classe \code{Figura}, garantindo que cada subclasse forneça sua implementação, aproveitando-se do polimorfismo.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlemptyclass[type=abstract]{Figura}
	\umlemptyclass[x=-3,y=-3.5]{Retangulo}
	\umlemptyclass[y=-3.5]{Triangulo}
	\umlemptyclass[x=2.75,y=-3.5]{Circulo}
	
	\umlinherit[geometry=|-]{Retangulo}{Figura}
	\umlinherit{Triangulo}{Figura}
	\umlinherit[geometry=|-]{Circulo}{Figura}
	\end{tikzpicture}
	
	\caption{Estrutura de classes para figuras desenháveis}
	\label{fig:realizacao-figuras}
\end{figure}

Porém, o mesmo sistema possui as classes \code{Fonte}, \code{Serif} e \code{Grossa}, que definem as fontes de texto de um elemento gráfico. Estas classes também devem implementar seus métodos \code{desenhar}. Logo, o método de desenho não é exclusivo das figuras, portanto não fazem parte da sua classe.

A Figura~\ref{fig:realizacao-figuras-fontes} apresenta a situação do diagrama de classes incluindo a estrutura de classes das fontes. Diante disso, qual a forma mais adequada de estruturar o sistema para garantir que tanto as figuras quanto as fontes implementem o método \code{desenhar}? Este método deve estar definido em \code{Figura} ou \code{Fonte}? As figuras devem estender \code{Fonte}? As figuras e as fontes devem estender uma nova classe?

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlemptyclass[type=abstract]{Figura}
	\umlemptyclass[x=-3,y=-3.5]{Retangulo}
	\umlemptyclass[y=-3.5]{Triangulo}
	\umlemptyclass[x=2.75,y=-3.5]{Circulo}
	
	\umlinherit[geometry=|-]{Retangulo}{Figura}
	\umlinherit{Triangulo}{Figura}
	\umlinherit[geometry=|-]{Circulo}{Figura}
	
	\umlemptyclass[x=7,type=abstract]{Fonte}
	\umlemptyclass[x=5.5,y=-3.5]{Serif}
	\umlemptyclass[x=8.5,y=-3.5]{Grossa}
	
	\umlinherit[geometry=|-]{Serif}{Fonte}
	\umlinherit[geometry=|-]{Grossa}{Fonte}
	\end{tikzpicture}
	
	\caption{Estrutura de classes para figuras e fontes desenháveis}
	\label{fig:realizacao-figuras-fontes}
\end{figure}

Adotar herança para resolver este problema não é a solução correta. Uma herança deve ser aplicada estritamente quando o relacionamento entre as classes responde a uma relação \textbf{``É UM''}. Neste caso, uma figura \textbf{não é uma} fonta, e uma fonte \textbf{não é uma} figura. Para resolver este problema, o ideal seria uma forma de apenas definir que as figuras e as fontes devem implementar o método \code{desenhar}. Isso é possível com uma \textbf{interface}!

Uma interface serve para isso, definir um contrato onde as classes que a realizam devem implementar os seus métodos. Com isso, podemos definir uma interface \code{Desenhavel} que exige que as classes que a implementem apresentem a implementação do método \code{desenha}. O trecho de código abaixo mostra a definição de uma interface.

\begin{minted}{java}
public interface Desenhavel {
	void desenhar();
}
\end{minted}

Basta então fazer com que as classes \code{Figura} e \code{Fonte} realizem (ou implementem) a interface criada, fazendo com que suas subclasses tenham que implementar o método de desenho. Logo, o uso de interfaces (ou realização) é diretamente aplicável quando queremos definir um comportamento aplicável a distintas classes, sem que estas tenham um vínculo semântico. Os códigos a seguir mostram estas definições.

\begin{minted}{java}
public abstract class Figura implements Desenhavel {
	private String cor;
	public abstract double area();
	public double perimetro();
	public void desenhar() {
		//implementação aqui.
	}
}
\end{minted}

\begin{minted}{java}
public abstract class Fonte implements Desenhavel {
	public void desenhar() {
		//implementação aqui.
	}
}
\end{minted}

Repare que, neste caso, as classes \code{Figura} e \code{Fonte} não são obrigadas a implementar o método \code{desenhar}, pois são abstratas (o que não impede sua implementação). No entanto, neste caso a obrigatoriedade de implementação é passada às suas subclasses concretas. Se a superclasse \code{Fonte} (por exemplo) implementar o método \code{desenhar}, as classes \code{Serif} e \code{Grossa} não precisam fazê-lo, a não ser que queiram sobrescrever o método. Se a classe \code{Fonte} não implementar o método, isso deve ser feito em \code{Serif} e \code{Grossa}.

A versão final do diagrama de classes é apresentada pela Figura~\ref{fig:realizacao-figuras-completo}. A interface é representada usando o estereótipo \texttt{<<interface>>}. Perceba que entidades de diferentes naturezas (\code{Figura} e \code{Fonte}) implementam a interface. Ou seja, o contrato definido por ela serve para classes sem um vínculo semântico.

\begin{figure}[h]
	\centering
	
	\begin{tikzpicture}
	\umlemptyclass[type=abstract]{Figura}
	\umlemptyclass[x=-3,y=-3.5]{Retangulo}
	\umlemptyclass[y=-3.5]{Triangulo}
	\umlemptyclass[x=2.75,y=-3.5]{Circulo}
	
	\umlinherit[geometry=|-]{Retangulo}{Figura}
	\umlinherit{Triangulo}{Figura}
	\umlinherit[geometry=|-]{Circulo}{Figura}
	
	\umlemptyclass[x=7,type=abstract]{Fonte}
	\umlemptyclass[x=5.5,y=-3.5]{Serif}
	\umlemptyclass[x=8.5,y=-3.5]{Grossa}
	
	\umlinherit[geometry=|-]{Serif}{Fonte}
	\umlinherit[geometry=|-]{Grossa}{Fonte}
	
	\umlemptyclass[x=3.5,y=3,type=interface]{Desenhavel}
	\umlreal[geometry=|-]{Figura}{Desenhavel}
	\umlreal[geometry=|-]{Fonte}{Desenhavel}
	\end{tikzpicture}
	
	\caption{Estrutura de classes para figuras e fontes com interface}
	\label{fig:realizacao-figuras-completo}
\end{figure}

\textbf{OBS:} a realização é representada na UML por uma linha tracejada e um triângulo não preenchido do lado da interface.

\subsection{Mais polimorfismo}

Com as interfaces, podemos usufruir de uma capacidade ainda maior de polimorfismo. Se tivermos uma lista de figuras (objetos de \code{Figura}), por exemplo, podemos nos referir a elas como desenháveis e chamar os métodos definidos na interface (contrato) \code{Desenhavel}. O trecho de código abaixo exemplifica este caso, onde ambos os laços de repetição são válidos.

\begin{minted}{java}
public void run() {
	List<Figura> figuras = criaListaFiguras();
	
	for(Figura f: figuras) {
		f.desenhar();
	}
	
	for(Desenhavel d: figuras) {
		d.desenhar();
	}
}
\end{minted}

Se futuramente novas classes forem incluídas no sistema como subclasses de \code{Figura}, a aplicação continuará funcionando normalmente, uma vez que a herança e a realização garantem a existência do método \code{desenhar}.

Além disso, é possível criar métodos que operem sobre objetos que implementem a interface \code{Desenhavel}, independente da classe à qual o objeto pertença. Ou seja, as interfaces (realização) fornecem um nível ainda maior de flexibilidade. O trecho de código abaixo exemplifica o uso da realização para criação de rotinas polimórficas.

\begin{minted}{java}
public void desenhaComponente(Desenhavel d) {
	d.desenha();
}

public void desenhaComponentes(List<Desenhavel> lista) {
	for(Desenhavel d: lista) {
		d.desenha();
	}
}
\end{minted}

Se futuramente novas classes que implementem a interface \code{Desenhavel} forem incluídas no sistema, a aplicação continuará funcionando normalmente, uma vez que os métodos \code{desenhaComponente} e \code{desenhaComponentes} fazem uso do polimorfismo oriundo da realização.
 
 
