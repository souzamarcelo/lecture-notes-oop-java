\chapter{Linguagem Java}

\section{Variáveis e constantes}
Uma variável é um mapeamento para um espaço alocado de memória, no qual se pode armazenar valores de um determinado tipo. O exemplo abaixo mostra a declaração de variáveis, atribuição de valores e sua recuperação.

\begin{minted}{java}
int idade;                  //Declaração
idade = 10;                 //Atribuição
int valor = idade;          //Recuperação
System.out.println(idade);  //Recuperação e apresentação
\end{minted}

Uma constante nada mais é do que uma variável que possui um valor predeterminado, com alteração não permitida. O trecho de código abaixo exemplifica a declaração de uma constante (com seu valor fixo) e a recuperação deste valor. A criação de uma constante é feita pelo uso da palavra reservada \code{final}, que torna seu valor fixo e não permite alteração (valor final).

\begin{minted}{java}
final int matricula = 512010681;  //Declaração e atribuição
int aluno = matricula;            //Recuperação
System.out.println(matricula);    //Recuperação
\end{minted}

\section{Tipos primitivos em Java}

Existem quatro categorias básicas para variáveis em Java: numérico (armazenamento de números), caracter (armazenamento de caracteres), alfanumérico (armazenamento de valores textuais) e lógico (armazenamento de valores lógicos -- verdadeiro e falso). A Tabela~\ref{tab:tipos-primitivos} resume os tipos primitivos em Java para cada categoria e o tamanho ocupado em memória por variáveis de cada tipo.

\begin{table}[ht]
	\centering
	\begin{tabular}{llr}
		\hline
		\textbf{Categoria}    & \textbf{Tipo}    & \textbf{Tamanho} \\ \hline
		numérica     & byte   & 8 bits \\
		numérica     & short   & 16 bits \\
		numérica     & int     & 32 bits \\
		numérica     & long    & 64 bits \\
		numérica     & float   & 32 bits \\
		numérica     & double  & 64 bits \\
		alfanumética & char    & 16 bits \\
		lógica       & boolena & 1 bit \\\hline
	\end{tabular}
	\caption{Tipos primitivos em Java}
	\label{tab:tipos-primitivos}
\end{table}

O trecho de código abaixo mostra o uso de variáveis dos diferentes tipos, com o armazenamento de valores e a recuperação para apresentação em tela.

\begin{minted}{java}
String nome = "João";
int idade = 15;
char sexo = 'M';
boolean aprovado = true;
System.out.println("Dados do acadêmico"
                 + "\nNome: " + nome
                 + "\nIdade: " + idade
                 + "\nSexo: " + sexo
                 + "\nAprovado: " + aprovado);
\end{minted}

\section{Leitura de valores do usuário}

A classe \code{Scanner} pode ser utilizada para a leitura de valores a partir do console. Esta classe memoriza o valor digitado pelo usuário e armazena em uma variável indicada. O exemplo abaixo mostra a criação de um objeto (\code{scanner}) desta classe e a posterior leitura de valores.


\begin{minted}{java}
Scanner scanner = new Scanner(System.in);
int valorInteiro = scanner.nextInt();
String valorTextual = scanner.next();
double d = scanner.nextDouble();
\end{minted}

Uma alternativa ao uso do console como entrada e saída de dados consiste em apresentar ao usuário uma caixa de diálogo com as informações de saída ou com a solicitação de uma entrada. A classe \code{JOptionPane} fornece os métodos necessários a esta tarefa. O método \code{showMessageDialog} permite a apresentação de uma mensagem ao usuário, enquanto o método \code{showInputDialog} permite solicitar um valor ao usuário. Note que o método retorna um valor do tipo \code{String}, que deve ser convertido ao tipo desejado, caso diferente. O exemplo abaixo mostra o uso da classe \code{JOptionPane} para as tarefas supracitadas.

\begin{minted}{java}
JOptionPane.showMessageDialog(null, "Mensagem ao usuário");
int valorInteiro = Integer.parseInt(JOptionPane.showInputDialog("Digite um valor inteiro:"));
String valorTextual = JOptionPane.showInputDialog("Digite uma String:");
double d = Double.parseDouble(JOptionPane.showInputDialog("Digite um valor double: "));
\end{minted}


\section{Operadores aritméticos}

Operadores aritméticos são funções e operadores predefinidos para realização de cálculos matemáticos. Eles atuam sobre valores ou variáveis numéricas. A Tabela~\ref{tab:operadores-aritmeticos} apresenta os principais operadores aritméticos disponíveis na linguagem Java, seus exemplos e sua descrição.

\begin{table}[H]
	\centering
	\begin{tabular}{c|c|l}
		\hline
		\textbf{Operador} & \textbf{Exemplo} & \textbf{Descrição}\\ \hline
		\texttt{=}   	 & \texttt{x = y}	   & O conteúdo da variável \texttt{y} é atribuído à variável \texttt{x}.  \\
		\texttt{+} 		 & \texttt{x + y}     & Soma o conteúdo de \texttt{x} e de \texttt{y}.\\
		\texttt{-}  		 & \texttt{x - y}     & Subtrai o conteúdo de \texttt{y} do conteúdo de \texttt{x}.\\
		\texttt{*}  		 & \texttt{x * y}     & Multiplicação conteúdo de \texttt{x} com o conteúdo de \texttt{y}.\\
		\texttt{/}  		 & \texttt{x / y}     & Divide o conteúdo de \texttt{x} pelo conteúdo de \texttt{y}.\\
		\texttt{\%} 		 & \texttt{x \% y} & Obtém o resto da divisão inteira de \texttt{x} por \texttt{y}.\\
		\texttt{++}  	 & \texttt{x++}     & Equivale a \texttt{x = x + 1}.\\
		\texttt{----}  	 & \texttt{x----}     & Equivale a \texttt{x = x - 1}.\\ \hline                           
	\end{tabular}
	\caption{Operadores Aritméticos}
	\label{tab:operadores-aritmeticos}
\end{table}

O trecho de código abaixo exemplifica a aplicação dos operadores supracitados. Em expressões mais complexas, os operadores têm a mesma precedência que na matemática básica, a qual pode ser alterada com o uso de parêntesis.

\begin{minted}{java}
int a, b, resultado;
a = 10;
b = 3;
resultado = a + b;         //resultado -> 13
resultado = a - b;         //resultado -> 7
resultado = a * b;         //resultado -> 30
resultado = a / b;         //resultado -> 3
resultado = (a / b) + a ;  //resultado -> 13
resultado = a % b;         //resultado -> 1
resultado = a++;           //resultado -> ???
resultado = b--;           //resultado -> ???
\end{minted}

O resultado das expressões apresentadas nas linhas 10 e 11 é \code{10} e \code{3}, respectivamente. Isto se deve ao fato de que as operações \code{a++} e \code{b--} são realizadas após a atribuição, ou seja, após os valores originais serem armazenados na variável \code{resultado}. Para que as operações sobre as variáveis \code{a} e \code{b} sejam feitas antes da atribuição, deve-se utilizar \code{++a} e \code{++b}.

\section{Operadores lógicos}
Operadores lógicos são funções ou operadores predefinidos para atuação sobre valores ou variáveis booleanas (lógicas), avaliando seu conteúdo. Estes operadores retornam um valor booleano (\code{true} ou \code{false}) como resultado. A Tabela~\ref{tab:operadores-logicos} apresenta uma visão geral dos operadores lógicos (\texttt{AND}, \texttt{OR} e \texttt{NOT}). As Tabelas~~\ref{tab:operador-e},~\ref{tab:operador-ou} e~\ref{tab:operador-not} detalham o funcionamento de cada operador, apresentando a tabela verdade de cada um.

\begin{table}[H]
	\centering
	\begin{tabular}{l|c|l}
		\hline
		\textbf{Operador}       & \textbf{Exemplo}  & \textbf{Descrição}                               \\ \hline
		E/AND -- \texttt{\&\&} & \texttt{x \&\& y} & Representa o conteúdo de \texttt{x} \textbf{E} o conteúdo de \texttt{y}  \\
		
		OU/OR -- \texttt{||}   & \texttt{x || y}   & Representa o conteúdo de \texttt{x} \textbf{OU} o conteúdo de \texttt{y} \\
		
		NÃO/NOT -- \texttt{!}  & \texttt{!x}       & Representa o valor inverso de \texttt{x} (não \texttt{x}). \\ \hline
	\end{tabular}
	\caption{Visão geral dos operadores lógicos}
	\label{tab:operadores-logicos}
\end{table}

\begin{table}[H]
	\centering
	\begin{tabular}{c|c|c|c}
		\hline
		\textbf{Valor de \texttt{x}} & \textbf{Operador} & \textbf{Valor de \texttt{y}} & \textbf{Resultado} \\ \hline
		\texttt{\color{green!50!black}TRUE}       & \texttt{\&\&}     & \texttt{\color{green!50!black}TRUE}       & \texttt{\color{green!50!black}TRUE}      \\
		\texttt{\color{green!50!black}TRUE}       & \texttt{\&\&}     & \texttt{\color{red!50!black}FALSE}      & \texttt{\color{red!50!black}FALSE}     \\
		\texttt{\color{red!50!black}FALSE}      & \texttt{\&\&}     & \texttt{\color{green!50!black}TRUE}       & \texttt{\color{red!50!black}FALSE}     \\
		\texttt{\color{red!50!black}FALSE}      & \texttt{\&\&}     & \texttt{\color{red!50!black}FALSE}      & \texttt{\color{red!50!black}FALSE}     \\ \hline
	\end{tabular}
	\caption{Tabela verdade para o operador \texttt{AND}}
	\label{tab:operador-e}	
\end{table}

\begin{table}[H]
	\centering
	\begin{tabular}{c|c|c|c}
		\hline
		\textbf{Valor de \texttt{x}} & \textbf{Operador} & \textbf{Valor de \texttt{y}} & \textbf{Resultado} \\ \hline
		\texttt{\color{green!50!black}TRUE}       & \texttt{||}       & \texttt{\color{green!50!black}TRUE}       & \texttt{\color{green!50!black}TRUE}      \\
		\texttt{\color{green!50!black}TRUE}       & \texttt{||}       & \texttt{\color{red!50!black}FALSE}      & \texttt{\color{green!50!black}TRUE}      \\
		\texttt{\color{red!50!black}FALSE}      & \texttt{||}       & \texttt{\color{green!50!black}TRUE}       & \texttt{\color{green!50!black}TRUE}      \\
		\texttt{\color{red!50!black}FALSE}      & \texttt{||}       & \texttt{\color{red!50!black}FALSE}      & \texttt{\color{red!50!black}FALSE}     \\ \hline
	\end{tabular}
	\caption{Tabela verdade para o operador \texttt{OR}}
	\label{tab:operador-ou}	
\end{table}

\begin{table}[H]
	\centering
	\begin{tabular}{c|c|c}
		\hline
		\textbf{Operador} & \textbf{Valor de \texttt{x}} & \textbf{Resultado} \\ \hline
		\texttt{!}        & \texttt{\color{green!50!black}TRUE}       & \texttt{\color{red!50!black}FALSE}     \\
		\texttt{!}        & \texttt{\color{red!50!black}FALSE}      & \texttt{\color{green!50!black}TRUE}      \\ \hline
	\end{tabular}
	\caption{Tabela verdade para o operador \texttt{NOT}}
	\label{tab:operador-not}
\end{table}

O trecho de código a seguir mostra a aplicação dos operadores lógicos sobre variáveis booleanas.

\begin{minted}{java}
boolean a, b, resultado;
a = true;
b = false;
resultado = a && b;  //resultado -> false
resultado = a || b;  //resultado -> true
resultado = !a;      //resultado -> false
\end{minted}

\section{Operadores relacionais}
Operadores relacionais são funções ou operadores predefinidos para atuação sobre valores ou variáveis de diferentes tipos, comumente numéricos. Estes operadores avaliam o conteúdo de duas variáveis ou grandezas e os compara, retornando um valor lógico (\code{true} ou \code{false}). Em outras palavras, estes operadores relacionam duas variáveis ou duas grandezas, comparando-as.

\begin{table}[H]
	\centering
	\begin{tabular}{l|c|l}
		\hline
		\textbf{Operador}       & \textbf{Exemplo}                              & \textbf{Descrição}                                       \\ \hline
		Igual -- \texttt{==}          &       \texttt{x==y}                        & Conteúdo de \texttt{x} é igual ao conteúdo de \texttt{y}?          \\
		Diferente -- \texttt{!=}      &         \texttt{x!=y}                       & Conteúdo de \texttt{x} é diferente do conteúdo de \texttt{y}?      \\
		Maior -- \texttt{>}          & \texttt{x > y} 			  & Conteúdo de \texttt{x} é maior que o conteúdo de \texttt{y}?       \\
		Menor -- \texttt{<}          & \texttt{x < y}       		  & Conteúdo de \texttt{x} é menor que o conteúdo de \texttt{y}?       \\
		Maior ou igual -- \texttt{>=} & \texttt{x >= y} & Conteúdo de \texttt{x} é maior ou igual ao conteúdo de \texttt{y}? \\
		Menor ou igual -- \texttt{<=} & \texttt{x <= y}       & Conteúdo de \texttt{x} é menor ou igual ao conteúdo de \texttt{y}? \\ \hline
	\end{tabular}
	\caption{Operadores relacionais}
\end{table}

O trecho de código a seguir mostra a aplicação dos diferentes operadores relacionais, avaliando o conteúdo das variáveis numéricas \code{a} e \code{b}.

\begin{minted}{java}
int a, b;
boolean resultado;
a = 5;
b = 2;
resultado = (a == b); //resultado -> false
resultado = (a != b); //resultado -> true
resultado = (a > b);  //resultado -> true
resultado = (a < b);  //resultado -> false
resultado = (a >= b); //resultado -> true
resultado = (a <= b); //resultado -> false
\end{minted}

\section{Estruturas condicionais}
Estruturas condicionais (ou estruturas de seleção) permitem definir um techo de código que é executado apnas em condições determinadas. Ou seja, elas permitem que o fluxo de execução seja desviado, de acordo com condições predefinidas.

\subsection{Estruturas condicionais simples}
A instrução \code{if} permite criar uma estrutura condicional simples, que faz a verificação de uma condição e executa um trecho de código somente se a condição for verdadeira (retornar \code{true}). O trecho de código abaixo apresenta um exemplo da aplicação de uma estrutura condicional simples.

\begin{minted}{java}
int a = 10;
int b = 5;
if(a > b) {
	System.out.println("Este código só é executado se a > b");
}
\end{minted}

A condição definida pela expressão \code{if} consiste em avaliar o conteúdo das variáveis \code{a} e \code{b} com o operador relacional \code{>}. Caso a expressão \code{a > b} for verdadeira (como no caso do exemplo), as instruções internas à estrutura condicional serão executadas.

É possível utilizar a cláusula \code{else} para definir um conjunto de instruções executadas exclusivamente quando a condição não for satisfeira (retornar \code{false}). O trecho de código a seguir exemplifica o uso da cláusula \code{else}.

\begin{minted}{java}
int a = 10;
int b = 5;
if(a > b) {
	System.out.println("Este código só é executado se a > b");
} else {
	System.out.println("Este código só é executado se a <= b");
}
\end{minted}

\subsection{Estruturas condicionais aninhadas}
É possível definir estruturas condicionais internas a outras estruturas condicionais. Dessa forma, é possível encadear e testar diferentes condições e sub-condições. O trecho de código abaixo mostra um exemplo de estruturas condicionais aninhadas.

\begin{minted}{java}
int a = 10;
int b = 5;
if(a > b) {
	if(b < 50) {
		System.out.println("Este código só é executado se a > b e b < 50");
	}
} else {
	if(a > 30) {
		System.out.println("Este código é executado quando a condição (a > b) não é satisfeita e a > 30");
	}
}
\end{minted}

No exemplo apresentado, uma primeira condição é testada (\code{a > b}). Caso ela seja verdadeira, a condição \code{b < 50} é então testada. Caso contrário, a condição \code{a > 30} é testada.

\subsection{Estruturas condicionais e múltipla escolha}
O Java (assim como outras linguagens) fornece um terceiro tipo de estrutura condicional para múltiplas escolhas. Estas estruturas testam o valor de uma variável e selecionam uma entre diferentes opções, executando o código correspondente. Um exemplo é apresentado no trecho de código abaixo. Atente para o uso da cláusula \code{break} em cada condição, evitando que condições não desejadas sejam satisfeitas.

\begin{minted}{java}
int a = 2;

switch(a) {
	case 1:
		System.out.println("O valor de a é 1");
		break;
	case 2:
		System.out.println("O valor de a é 2");
		break;
	case 3:
		System.out.println("O valor de a é 3");
		break;
	default:
		System.out.println("O valor de a não é nenhum dos valores testados");
		break;
}

\end{minted}

\section{Laços de repetição}
Laços de repetição permitem a execução repetida de um trecho de código. Ou seja, o programador define a forma como um processo é realizado e o replica repetidas vezes. Exemplo: fazer a leitura das notas dos alunos da disciplina para cálculo da média. Como existem vários alunos, o processo de leitura e cômputo da média deve ser executado múltiplas vezes.

\subsection{Laço de repetição contado -- ``for''}
A primeira forma de implementação de laço de repetição é determinando o número de iterações do mesmo. Isso é feito através do laço \code{for}, no qual se define uma variável contadora, seu valor inicial, sua condição de parada e o incremento (ou decremento) a cada iteração. O trecho de código abaixo exemplifica o uso do laço de repetição \code{for}.

\begin{minted}{java}
for(int i = 0; i < 10; i++) {
	System.out.println("Este texto será impresso 10 vezes!");
}
\end{minted}

O trecho de código a seguir mostra a aplicação do laço \code{for}. O primeiro laço (linhas 1 a 3) inicia em \code{10} e decrementa a variável contadora enquanto \code{i > 0}. Logo, o texto é impresso 10 vezes. O segundo laço (linhas 5 a 10) utiliza variáveis externas (\code{inicio} e \code{fim}) para controlar as iterações. A cláusula \code{break} permite quebrar a execução do laço, isto é, parar sua execução e pular para a linha subsequente a ele.

\begin{minted}{java}
for(int i = 10; i > 0; i--) {
	System.out.println("Esse texto será impresso 10 vezes!");
}

int inicio = 1, fim = 10;
for(int i = inicio; i <= fim; i++) {
	System.out.println("Executando...");
	if(i > 100)
		break;
}
\end{minted}

\subsection{Laço de repetição condicional com teste no início -- ``while''}
Os laços de repetição condicionais repetem a execução do conjunto de instruções de acordo com uma condição. Ou seja, enquanto a condição for verdadeira, o código correspondente é executado. A primeira forma de laço de repetição condicional é o \code{while}, que define o teste condicional no início do laço. Um exemplo básico é apresentado a seguir, onde o conjunto de instruções é executado enquanto a condição \code{i < 10} for verdadeira. Atente para a necessidade de atualização da variável de controle (\code{i} -- linha 4).

\begin{minted}{java}
int i = 0;
while (i < 10) {
	System.out.println("Este texto será impresso 10 vezes");
	i++;
}
\end{minted}

No exemplo a seguir, utilizamos uma variável booleana (\code{continua}) para controlar as repetições do laço. Igualmente, é necessário definir o caso em que esta variável torna-se \code{false}, evitando um laço infinito. No exemplo, a variável recebe \code{false} quando a variável \code{i} for maior que \code{1000} (linhas 4 a 7). 

\begin{minted}{java}
boolean continua = true;
while(continua) {
	i *= 2;
	if(i > 1000) {
		System.out.println("i -> " + i);
		continua = false;
	}
}
\end{minted}

\subsection{Laço de repetição condicional com teste no final -- ``do''}
Analogamente ao método anterior, a estrutura \code{do..while} é um laço de repetição condicional, cujo teste é executado ao final da sua definição. Com isso, garante-se que o conjunto de instruções do laço será executado no mínimo uma vez, mesmo quando o condicional é falso. Isso se deve ao fato da estrutura primeiro executar as instruções e depois testar o condicional.

O código abaixo mostra o uso do laço \code{do..while}. A primeira definição do laço repete por 10 vezes, enquanto a condição \code{i < 10} se apresenta verdadeira. A segunda definição do laço possui uma condição falsa por definição (valor atribuído na linha 7). No entanto, a instrução (linha 10) é executada uma vez, pois o teste ocorre no final da estrutura de repetição.


\begin{minted}{java}
int i = 0;
do {
	System.out.println("Este texto será impresso 10 vezes");
	i++;
} while (i < 10);

boolean continua = false;

do {
	System.out.println("Esse texto será exibido uma vez, pois o teste é realizado no final!");
} while(continua);
\end{minted}

\section{Métodos}
O uso de métodos em programação segue o conceito de dividir para conquistar. Ou seja, um problema pode ser dividido em sub-problemas, menores e mais simples, de modo a resolver cada sub-problema separadamente e unir a solução deles para resolver o problema maior, simplificando o processo.

Uma característica importante do uso de métodos é a possibilidade de isolar um trecho específico de código, que pode ser chamado de diferentes pontos do sistema, evitando a replicação de código. Isso garante flexibilidade e manutenibilidade ao software, uma vez que a mudança no processo implica na alteração do código em um ponto único.

A definição de um método consiste no modificador de acesso, tipo de retorno, identificador (nome), conjunto de argumentos e o conjunto de instruções do método: \code{<modificador> <tipo retorno> <identificador> ([<argumentos>]) \{<instrucoes>\}}. Por definição, um método deve resolver um problema específico, portanto possui um identificador intuitivo com relação à sua função.

\subsection{Métodos sem retorno e sem parâmetros}
A maneira mais simples em que um método se apresenta é quando não possui retorno e não recebe parâmetros. Neste caso, definimos seu retorno como \code{void} e não informamos qualquer informação na área de parâmetros (entre parêntesis). Dessa forma, a implementação do método ficaria como apresentado no código abaixo. A chamada do método é feita pelo seu identificador. No exemplo apresentado acima, não existe retorno nem passagem de parâmetros, portanto a chamada se limita à instrução com o identificador do método.

\begin{minted}{java}
public void nomeMetodo() {
	System.out.println("Este código é executado quando o método é chamado");
}

//Chamada
nomeMetodo();
\end{minted}

\subsection{Métodos com retorno e sem parâmetros}
Frequentemente é desejável que o método retorne o resultado do seu processamento, de modo que possa ser utilizado pelo elemento que o invocou. Neste caso, deve-se definir o tipo de retorno e utilizar a cláusula \code{return} para retornar o valor desejado. O trecho de código abaixo ilustra a aplicação de um método com retorno.

\begin{minted}{java}
public static void main(String[] args) {
	int resultado = nomeMetodo();
	System.out.println("O resultado retornado é: " + resultado);
}

public static int nomeMetodo() {
	return 10;
}
\end{minted}

Neste exemplo, o método \code{nomeMetodo} retorna um valor constante (\code{10}). Este valor é recuperado no momento da chamada do método (linha~2) e posteriormente apresentado em tela (linha~3). Observe a necessidade da cláusula \code{static}, uma vez que o método é chamado pelo \code{main} (estático por definição).

\subsection{Métodos com parâmetros}
Finalmente, é possível enviar parâmetros ao método, os quais podem ser utilizados para o processamento desejado (estes métodos podem ser com ou sem retorno). Para isso, a definição do método contém a lista de parâmetros recebidos por ele. Esta lista é composta pelo tipo e identificador do parâmetro, separados por vírgula. O trecho de código abaixo exemplifica a definição e chamada de um método com passagem de parâmetros.

\begin{minted}{java}
public static void main(String[] args) {
	int resultado = nomeMetodo(50);
	System.out.println("O resultado retornado é: " + resultado);
}

public static int nomeMetodo(int parametro) {
	return parametro * 2;
}
\end{minted}

Neste exemplo, o método \code{nomeMetodo} recebe um parâmetro do tipo inteiro (\code{parametro} -- linha~4), retornando seu valor multiplicado por \code{2} (linha~7). A chamada do método (linha~2) passa como parâmetro o valor \code{50}, recuperando seu resultado na variável \code{resultado}. Logo, o valor resultante, apresentado em tela na linha~3, possui o valor \code{100}.

\section{Vetores}
Um vetor (também chamado de \textit{array}) é um conjunto de variáveis do mesmo tipo, que possuem o mesmo identificador (nome) e se distinguem por um índice. Dessa forma, é possível armazenar um conjunto de valores através do mesmo identificador, isto é, uma lista de valores. Estas estruturas são armazenadas sequencialmente em memória.

\subsection{Vetores unidimensionais}
Um vetor pode ter uma ou muitas dimensões. No caso de uma dimensão, chamamos vetor unidimensional (ou simplesmente vetor) e o acessamos através de um índice simples. O trecho de código a seguir mostra a declaração e inicialização de valores de um vetor.

\begin{minted}{java}
//Declaração de vetor de inteiros com 5 posições
int[] primeiroVetor = new int[5];

//Declaração e inicialização na mesma instrução
int[] segundoVetor = {1, 2, 3, 4, 5};
\end{minted}

Para atribuir valores e recuperá-los da lista, utilizamos o índice para acessar cada posição. Um vetor de tamanho \texttt{n} é indexado de \texttt{0} até \texttt{n - 1}. O exemplo abaixo mostra a atribuição de um valor à posição \code{0} do vetor e a recuperação do valor armazenado na posição \code{2}.

\begin{minted}{java}
primeiroVetor[0] = 10;        //Atribuição de valor
int valor = segundoVetor[2];  //Recuperação de valor
\end{minted}

Para percorrer todas as posições de um vetor (para armazenar valores ou recuperá-los, por exemplo), deve-se utilizar um laço de repetição. O exemplo abaixo mostra a aplicação do laço \code{for} para realizar esta tarefa. Para isso, o laço inicia em \code{0} e vai até \code{n - 1}, sendo \code{n} o tamanho do vetor (a função \code{length} recupera o tamanho do vetor -- linha~1). No primeiro laço, são armazenados valores a cada posição do vetor. No segundo laço, estes valores são recuperados e apresentados em tela.

\begin{minted}{java}
for(int i = 0; i < primeiroVetor.length; i++) {
	primeiroVetor[i] = i * 10;
}

for(int i = 0; i < segundoVetor.length; i++) {
	System.out.println(segundoVetor[i]);
}
\end{minted}

\subsection{Vetores multidimensionais}
Ao utilizar mais de uma dimensão, chamamos vetor multidimensional. Um uso comum é utilizar duas dimensões, de modo a criar uma estrutura de tabela, chamada matriz. Neste caso, podemos armazenar valores às células da tabela e, portanto, acessamos cada célula através de dois índices (linha e coluna). O código abaixo mostra a criação e inicialização da matriz. Como a estrutura possui duas dimensões, devemos definir o tamanho de cada dimensão, isto é, o número de linhas e o número de colunas da matriz.

\begin{minted}{java}
//Declaração de uma matriz de Strings 5x5
String[][] primeiraMatriz = new String[5][5];

//Declaração e inicialização
String[][] segundaMatriz = {{"a", "b"},{"c", "d"}};
\end{minted}

Para acessar os valores (na atribuição e na recuperação), devemos informar a linha e coluna desejadas. O trecho de código abaixo ilustra estes casos.

\begin{minted}{java}
primeiraMatriz[2][4] = "Texto";      //Atribuição de valor
String letra = segundaMatriz[1][1];  //Recuperação de valor
\end{minted}

Da mesma forma que fazemos com vetores unidimensionais, utilizamos laços de repetição para percorrer estas estruturas. No entanto, como temos duas dimensões, precisamos de dois laços de repetição aninhados, de modo a percorrer cada elemento da primeira e da segunda dimensões (respectivamente das linhas e colunas da matriz). O código abaixo mostra o comportamento supracitado, onde a \code{String} \code{****} é atribuída a cada posição da matriz.

\begin{minted}{java}
for(int i = 0; i < primeiraMatriz.length; i++) {
	for(int j = 0; j < primeiraMatriz.length; j++) {
		primeiraMatriz[i][j] = "***";
	}
}
\end{minted}

\textbf{Observação:} os mesmos conceitos se aplicam a matrizes com mais de duas dimensões.

\section{Manipulação de String}
Frequentemente valores textuais (\code{Strings}) precisam ser tratados (verificar se o usuário informou algum caracter não numérico, por exemplo). Neste caso, o Java fornece uma série de funções para manipulação de \code{Strings}.

Uma função muito útil é a \code{charAt(i)}, que retorna o caracter da posição \code{i} de uma \code{String}. O trecho de código abaixo mostra o funcionamento desta função, onde diferentes posições da variável \code{palavra} são acessadas por meio da função supracitada.

\begin{minted}{java}
String palavra = "programação";
System.out.println(palavra.charAt(0)); // p
System.out.println(palavra.charAt(2)); // o
System.out.println(palavra.charAt(3)); // g
System.out.println(palavra.charAt(7)); // a
\end{minted}

O código abaixo apresenta um exemplo, onde o caracter \code{'*'} é buscado dentro de uma \code{String}. Para isso, pode-se utilizar um laço de repetição, de modo a percorrer cada posição da \code{String}. Assim como com vetores, é possível recuperar o tamanho da \code{String} através da função \code{length}, para que se saiba o intervalo a ser percorrido pelo laço de repetição. O resultado da execução do código abaixo é: ''Valor encontrado na posição 5!``.

\begin{minted}{java}
String texto = "H8k#s*0pq.";
char busca = '*';
for(int i = 0; i < texto.length; i++) {
	if(texto.charAt(i) == busca) {
		System.out.println("Valor encontrado na posição " + i + "!");
		break;
	}
}
\end{minted}

Existem várias outras funções para manipulação de \code{Strings} em Java. A Tabela~\ref{tab:manipulacao-strings} sumariza as principais delas e apresenta sua descrição.

\begin{table}[H]
	\centering
	\begin{tabular}{>{\raggedleft}p{0.41\linewidth}|p{0.535\linewidth}}
		\hline
		\textbf{Método}   						& \textbf{Descrição}                                                                         \\ \hline
		\texttt{substring(int inicio, int fim)} & Retorna a substring a partir do caractere da posição  \texttt{inicio} até a posição \texttt{fim}. \\
		\texttt{equals(String s)}               & Verifica se a \texttt{String} é igual a \texttt{s}.                                                    \\
		\texttt{equalsIgnoreCase(String s)}     & Identico ao anterior, mas sem diferenciar entre caracteres maiúsculos e minúsculos. \\
		\texttt{contains(String s)}             & Verifica se \texttt{s} é uma \texttt{substring} do objeto que chama a função.                         \\
		\texttt{startsWith(String s)}           & Verifica se a \texttt{String} inicia com a \texttt{substring} \texttt{s}.                                      \\
		\texttt{endsWith(String s)}             & Verifica se a \texttt{String} termina com a \texttt{substring} \texttt{s}.                                     \\
		\texttt{toUpperCase()}                  & Transforma todos os caracteres em maiúsculos.                                       \\
		\texttt{toLowerCase()}                  & Transforma todos os caracteres em minúsculos.                                      \\
		\texttt{replace(String s1, String s2)}  & Substitui os caracteres indicados em \texttt{s1} pelos indicados em \texttt{s2}.                 \\
		\texttt{trim()}                         & Remove espaços no início e final da \texttt{String}.      \\ \hline                                  
	\end{tabular}
	\caption{Funções para manipulação de Strings em Java}
	\label{tab:manipulacao-strings}
\end{table}